<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ReadNote Plus - E-Reader & Note-Taking</title>
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- JSZip for EPUB -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Google Fonts - Optimized for e-ink -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Literata:ital,opsz,wght@0,7..72,400;0,7..72,500;0,7..72,600;1,7..72,400&family=Source+Sans+3:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            /* E-ink optimized colors */
            --color-bg: #FAFAF8;
            --color-surface: #FFFFFF;
            --color-text: #1A1A1A;
            --color-text-secondary: #4A4A4A;
            --color-accent: #2D5016;
            --color-accent-light: #E8F0E4;
            --color-border: #D0D0D0;
            --color-highlight: #FFF3CD;

            /* Cozy palette */
            --color-wood-dark: #3D2314;
            --color-wood-medium: #5C3D2E;
            --color-wood-light: #8B5A2B;
            --color-cream: #F5E6D3;
            --color-parchment: #FDF8F0;
            --color-ember: #C65D3B;
            --color-amber: #D4A574;

            /* Reading settings */
            --font-size: 18px;
            --line-height: 1.8;
            --page-margin: 40px;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Source Sans 3', -apple-system, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            line-height: 1.5;
            min-height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: linear-gradient(180deg, var(--color-wood-medium) 0%, var(--color-wood-dark) 100%);
            border-right: 3px solid var(--color-wood-light);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
        }

        .app-title {
            font-family: 'Literata', Georgia, serif;
            font-size: 22px;
            font-weight: 600;
            color: var(--color-cream);
            margin-bottom: 4px;
        }

        .app-subtitle {
            font-size: 12px;
            color: var(--color-amber);
            opacity: 0.9;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cloud-indicator {
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .cloud-indicator.connected {
            color: #4CAF50;
            text-shadow: 0 0 6px rgba(76, 175, 80, 0.5);
        }

        .cloud-indicator.disconnected {
            color: #888;
            opacity: 0.6;
        }

        .cloud-indicator.syncing {
            color: #FFC107;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .upload-btn {
            width: 100%;
            padding: 14px;
            margin-top: 16px;
            background: linear-gradient(135deg, var(--color-ember) 0%, #E8854A 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(198, 93, 59, 0.4);
        }

        #fileInput {
            display: none;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--color-amber);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(212, 165, 116, 0.3);
        }

        .file-item {
            display: flex;
            gap: 12px;
            padding: 12px;
            margin-bottom: 10px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(212, 165, 116, 0.2);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-item:hover {
            background: rgba(255,255,255,0.12);
            border-color: var(--color-amber);
        }

        .file-item.active {
            background: rgba(212, 165, 116, 0.2);
            border-color: var(--color-ember);
        }

        .file-cover {
            width: 50px;
            height: 70px;
            border-radius: 4px;
            object-fit: cover;
            background: linear-gradient(135deg, var(--color-wood-light) 0%, var(--color-wood-dark) 100%);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: var(--color-cream);
            overflow: hidden;
        }

        .file-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            color: var(--color-cream);
            font-weight: 500;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-word;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .file-author {
            font-size: 11px;
            color: var(--color-amber);
            opacity: 0.8;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-size {
            font-size: 10px;
            color: var(--color-amber);
            opacity: 0.7;
        }

        .file-type {
            font-size: 8px;
            padding: 2px 6px;
            background: var(--color-ember);
            color: white;
            border-radius: 3px;
            font-weight: 600;
        }

        .file-progress {
            margin-top: 6px;
            font-size: 10px;
            color: var(--color-amber);
        }

        .progress-bar {
            height: 3px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--color-ember);
            border-radius: 2px;
            transition: width 0.3s;
        }

        .delete-file {
            background: none;
            border: none;
            color: var(--color-ember);
            font-size: 11px;
            cursor: pointer;
            margin-top: 8px;
            opacity: 0.7;
        }

        .delete-file:hover {
            opacity: 1;
            text-decoration: underline;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--color-bg);
        }

        /* Reader Header */
        .reader-header {
            padding: 12px 20px;
            background: var(--color-surface);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .book-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 200px;
        }

        .book-title {
            font-family: 'Literata', Georgia, serif;
            font-weight: 600;
            font-size: 16px;
            color: var(--color-text);
        }

        .book-author {
            font-size: 13px;
            color: var(--color-text-secondary);
        }

        .reader-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--color-bg);
            border-radius: 8px;
            border: 1px solid var(--color-border);
        }

        .control-label {
            font-size: 11px;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn {
            padding: 8px 16px;
            background: var(--color-accent);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #3D6B1E;
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: var(--color-accent);
            color: white;
            border-color: var(--color-accent);
        }

        .btn-icon:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .page-info {
            font-size: 13px;
            color: var(--color-text-secondary);
            min-width: 80px;
            text-align: center;
        }

        /* Reading Area */
        .reading-area {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Reader Panel - Paginated View */
        .reader-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--color-surface);
            position: relative;
            overflow: hidden;
        }

        .page-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            overflow: hidden;
            position: relative;
        }

        .page-container.showing-library {
            padding: 0;
        }

        .page-view {
            width: 100%;
            max-width: 800px;
            height: 100%;
            background: var(--color-surface);
            box-shadow: 0 2px 20px rgba(0,0,0,0.08);
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .page-content {
            flex: 1;
            padding: var(--page-margin);
            overflow: auto;
            font-family: 'Literata', Georgia, serif;
            font-size: var(--font-size);
            line-height: var(--line-height);
            color: var(--color-text);
            text-align: justify;
            hyphens: auto;
            -webkit-hyphens: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        /* CSS columns-based pagination for smooth text flow */
        .page-content-wrapper {
            column-width: 100vw;
            column-gap: 80px;
            column-fill: auto;
            height: 100%;
        }

        .page-content.two-columns .page-content-wrapper {
            column-count: 2;
            column-width: auto;
        }

        /* Page text content styling */
        .page-text-content {
            width: 100%;
            max-width: 700px;
            text-align: justify;
        }

        .page-text-content p {
            margin: 0 0 1em 0;
            text-indent: 1.5em;
        }

        .page-text-content p:first-child {
            text-indent: 0;
        }

        .page-text-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 1em auto;
        }

        /* PDF canvas styling */
        .page-content canvas {
            display: block;
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .page-content h1, .page-content h2, .page-content h3 {
            font-family: 'Literata', Georgia, serif;
            color: var(--color-text);
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            line-height: 1.3;
            column-span: all;
        }

        .page-content h1 {
            font-size: 1.8em;
            text-align: center;
            margin-top: 2em;
            margin-bottom: 1em;
        }

        .page-content h2 {
            font-size: 1.4em;
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 0.3em;
        }

        .page-content h3 {
            font-size: 1.2em;
        }

        .page-content p {
            margin: 0 0 1em 0;
            text-indent: 1.5em;
        }

        .page-content p:first-of-type,
        .page-content h1 + p,
        .page-content h2 + p,
        .page-content h3 + p {
            text-indent: 0;
        }

        .page-content p:first-of-type::first-letter {
            font-size: 3em;
            float: left;
            line-height: 1;
            margin-right: 0.1em;
            font-weight: 600;
        }

        .page-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 1em auto;
            border-radius: 4px;
        }

        .page-content blockquote {
            margin: 1em 2em;
            padding-left: 1em;
            border-left: 3px solid var(--color-accent);
            font-style: italic;
            color: var(--color-text-secondary);
        }

        /* Realistic Bookshelf Library */
        .library-grid {
            display: block;
            width: 100%;
            height: 100%;
            min-height: 100%;
            overflow-y: auto;
            background: linear-gradient(180deg, #2C1810 0%, #1A0F0A 100%);
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 5;
        }

        .library-grid::before {
            content: '';
            position: fixed;
            top: 0;
            left: 300px;
            right: 0;
            bottom: 0;
            background:
                radial-gradient(ellipse at 50% 0%, rgba(255,200,100,0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 20% 80%, rgba(255,150,50,0.1) 0%, transparent 40%);
            pointer-events: none;
            z-index: 0;
        }

        .library-header {
            text-align: center;
            padding: 40px 20px 20px;
            position: relative;
            z-index: 1;
        }

        .library-title {
            font-family: 'Literata', Georgia, serif;
            font-size: 2.2em;
            color: #F5E6D3;
            margin: 0 0 8px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 2px;
        }

        .library-subtitle {
            color: #D4A574;
            font-size: 1em;
            margin: 0;
            font-style: italic;
        }

        /* Bookshelf Structure */
        .bookshelf-container {
            padding: 0 40px 40px;
            position: relative;
            z-index: 1;
        }

        .bookshelf {
            max-width: 1100px;
            margin: 0 auto 0;
            position: relative;
        }

        .shelf-row {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 8px;
            padding: 20px 30px 0;
            min-height: 220px;
            position: relative;
            flex-wrap: wrap;
        }

        /* Wooden Shelf */
        .shelf-row::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(180deg,
                #8B5A2B 0%,
                #6B4423 30%,
                #5C3D2E 60%,
                #4A3020 100%);
            border-radius: 3px;
            box-shadow:
                0 4px 8px rgba(0,0,0,0.4),
                0 2px 4px rgba(0,0,0,0.3),
                inset 0 2px 2px rgba(255,255,255,0.1),
                inset 0 -2px 4px rgba(0,0,0,0.2);
        }

        /* Shelf brackets */
        .shelf-row::before {
            content: '';
            position: absolute;
            bottom: 15px;
            left: 10px;
            right: 10px;
            height: 8px;
            background: linear-gradient(90deg,
                #3D2314 0%, transparent 5%,
                transparent 95%, #3D2314 100%);
            z-index: -1;
        }

        /* 3D Book on Shelf */
        .shelf-book {
            width: 50px;
            height: 180px;
            position: relative;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: transform 0.3s ease, margin 0.3s ease;
            margin-bottom: 20px;
        }

        .shelf-book:hover {
            transform: translateY(-15px) rotateY(-20deg);
            margin-right: 20px;
            z-index: 10;
        }

        /* Book Spine (front face) */
        .book-spine {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                rgba(0,0,0,0.3) 0%,
                rgba(255,255,255,0.1) 10%,
                transparent 30%,
                transparent 70%,
                rgba(0,0,0,0.2) 100%);
            border-radius: 2px 4px 4px 2px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 4px;
            box-shadow:
                2px 2px 6px rgba(0,0,0,0.4),
                inset -2px 0 4px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .book-spine-title {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            font-family: 'Literata', Georgia, serif;
            font-size: 11px;
            font-weight: 600;
            color: rgba(255,255,255,0.9);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            max-height: 140px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            letter-spacing: 0.5px;
        }

        .book-spine-author {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            font-size: 8px;
            color: rgba(255,255,255,0.7);
            margin-top: 8px;
            max-height: 60px;
            overflow: hidden;
        }

        /* Book Cover (side face - visible on hover) */
        .book-cover-3d {
            position: absolute;
            width: 120px;
            height: 100%;
            left: 100%;
            transform-origin: left center;
            transform: rotateY(90deg);
            background: #f5f5f5;
            border-radius: 0 4px 4px 0;
            overflow: hidden;
            box-shadow: 4px 0 10px rgba(0,0,0,0.3);
        }

        .book-cover-3d img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .book-cover-3d .no-cover {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            text-align: center;
            background: linear-gradient(135deg, #f8f4f0 0%, #e8e0d8 100%);
        }

        .book-cover-3d .no-cover-title {
            font-family: 'Literata', Georgia, serif;
            font-size: 12px;
            font-weight: 600;
            color: #3D2314;
            margin-bottom: 8px;
        }

        .book-cover-3d .no-cover-author {
            font-size: 10px;
            color: #8B5A2B;
        }

        /* Book page edges (top) */
        .book-pages {
            position: absolute;
            top: 0;
            left: 2px;
            right: 2px;
            height: 3px;
            background: linear-gradient(90deg, #f5f5dc, #fffff0, #f5f5dc);
            transform: translateY(-100%);
            border-radius: 1px 1px 0 0;
        }

        /* Book colors - variety */
        .shelf-book:nth-child(6n+1) .book-spine { background-color: #8B0000; }
        .shelf-book:nth-child(6n+2) .book-spine { background-color: #1a365d; }
        .shelf-book:nth-child(6n+3) .book-spine { background-color: #2D5016; }
        .shelf-book:nth-child(6n+4) .book-spine { background-color: #4A3728; }
        .shelf-book:nth-child(6n+5) .book-spine { background-color: #5D3E6B; }
        .shelf-book:nth-child(6n+6) .book-spine { background-color: #8B4513; }

        /* Book height variations */
        .shelf-book:nth-child(3n+1) { height: 175px; }
        .shelf-book:nth-child(3n+2) { height: 185px; }
        .shelf-book:nth-child(5n+3) { height: 170px; }
        .shelf-book:nth-child(7n+4) { width: 55px; }
        .shelf-book:nth-child(11n+5) { width: 45px; }

        /* Progress indicator on spine */
        .book-progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(0,0,0,0.3);
        }

        .book-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            transition: width 0.3s;
        }

        /* Empty Shelf State */
        .empty-library {
            text-align: center;
            padding: 80px 20px;
        }

        .empty-library .empty-icon {
            font-size: 80px;
            margin-bottom: 20px;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }

        .empty-library .empty-text {
            font-size: 20px;
            color: #D4A574;
            margin-bottom: 30px;
            font-family: 'Literata', Georgia, serif;
        }

        .empty-library .upload-btn {
            display: inline-block;
            width: auto;
            padding: 16px 40px;
            font-size: 16px;
        }

        /* Decorative elements */
        .shelf-decoration {
            position: absolute;
            bottom: 25px;
            font-size: 24px;
            opacity: 0.8;
        }

        .shelf-decoration.left { left: 35px; }
        .shelf-decoration.right { right: 35px; }

        /* Responsive */
        @media (max-width: 768px) {
            .library-grid::before { left: 0; }
            .bookshelf-container { padding: 0 15px 30px; }
            .shelf-row { padding: 15px 15px 0; gap: 6px; min-height: 180px; }
            .shelf-book { width: 40px; height: 150px; }
            .book-spine-title { font-size: 9px; }
            .shelf-book:hover { transform: translateY(-10px); margin-right: 10px; }
        }

        /* Page Navigation Zones */
        .nav-zone {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 20%;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .nav-zone:hover {
            opacity: 1;
        }

        .nav-zone-left {
            left: 0;
            background: linear-gradient(to right, rgba(0,0,0,0.03), transparent);
        }

        .nav-zone-right {
            right: 0;
            background: linear-gradient(to left, rgba(0,0,0,0.03), transparent);
        }

        .nav-zone-icon {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: var(--color-text-secondary);
        }

        /* Page Footer */
        .page-footer {
            padding: 12px var(--page-margin);
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        /* Notes Panel */
        .notes-panel {
            width: 350px;
            background: linear-gradient(180deg, #4A3728 0%, #3A2A1F 100%);
            border-left: 1px solid rgba(212, 165, 116, 0.3);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .notes-panel.collapsed {
            width: 50px;
        }

        .notes-header {
            padding: 16px 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(212, 165, 116, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .notes-title {
            font-family: 'Literata', Georgia, serif;
            font-size: 16px;
            font-weight: 600;
            color: var(--color-cream);
        }

        .toggle-notes {
            background: none;
            border: none;
            color: var(--color-amber);
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
        }

        .notes-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .note-item {
            padding: 14px;
            background: rgba(253, 248, 240, 0.95);
            border-radius: 8px;
            margin-bottom: 12px;
            position: relative;
        }

        .note-page {
            font-size: 10px;
            color: var(--color-ember);
            background: rgba(198, 93, 59, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            display: inline-block;
            margin-bottom: 8px;
        }

        .note-text {
            font-size: 14px;
            color: var(--color-wood-dark);
            line-height: 1.5;
        }

        .note-time {
            font-size: 11px;
            color: var(--color-wood-medium);
            margin-top: 8px;
        }

        .note-drawing {
            width: 100%;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .delete-note {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #8B3A3A;
            font-size: 18px;
            cursor: pointer;
            opacity: 0.6;
        }

        .delete-note:hover {
            opacity: 1;
        }

        .note-input-area {
            padding: 16px;
            background: rgba(0,0,0,0.15);
            border-top: 1px solid rgba(212, 165, 116, 0.2);
        }

        .input-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            color: var(--color-cream);
            border: 1px solid rgba(212, 165, 116, 0.3);
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn.active {
            background: var(--color-ember);
            border-color: var(--color-ember);
        }

        .input-content {
            display: none;
        }

        .input-content.active {
            display: block;
        }

        .note-textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(212, 165, 116, 0.3);
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            resize: none;
            min-height: 80px;
            background: rgba(253, 248, 240, 0.95);
            color: var(--color-wood-dark);
        }

        .note-textarea:focus {
            outline: none;
            border-color: var(--color-ember);
        }

        .canvas-toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .color-input {
            width: 36px;
            height: 32px;
            border: 1px solid rgba(212, 165, 116, 0.4);
            border-radius: 4px;
            cursor: pointer;
            padding: 2px;
        }

        .size-input {
            width: 60px;
            padding: 6px 8px;
            border: 1px solid rgba(212, 165, 116, 0.3);
            border-radius: 4px;
            font-size: 12px;
            background: var(--color-parchment);
        }

        #drawingCanvas {
            width: 100%;
            height: 120px;
            border: 1px solid rgba(212, 165, 116, 0.3);
            border-radius: 8px;
            background: rgba(253, 248, 240, 0.95);
            cursor: crosshair;
            touch-action: none;
        }

        .add-note-btn {
            width: 100%;
            padding: 12px;
            margin-top: 12px;
            background: var(--color-accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .add-note-btn:hover {
            background: #3D6B1E;
        }

        /* Empty States */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 40px;
            text-align: center;
        }

        .empty-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.6;
        }

        .empty-text {
            font-family: 'Literata', Georgia, serif;
            font-size: 18px;
            color: var(--color-text-secondary);
            max-width: 300px;
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100%;
            background: var(--color-surface);
            box-shadow: -4px 0 20px rgba(0,0,0,0.1);
            z-index: 100;
            transition: right 0.3s;
            display: flex;
            flex-direction: column;
        }

        .settings-panel.open {
            right: 0;
        }

        .settings-header {
            padding: 20px;
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .settings-title {
            font-family: 'Literata', Georgia, serif;
            font-size: 20px;
            font-weight: 600;
        }

        .close-settings {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--color-text-secondary);
        }

        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .setting-group {
            margin-bottom: 24px;
        }

        .setting-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: 8px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .setting-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: var(--color-border);
            border-radius: 3px;
            outline: none;
        }

        .setting-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--color-accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-value {
            min-width: 50px;
            font-size: 14px;
            color: var(--color-text-secondary);
        }

        .setting-buttons {
            display: flex;
            gap: 8px;
        }

        .setting-btn {
            flex: 1;
            padding: 10px;
            background: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .setting-btn.active {
            background: var(--color-accent);
            color: white;
            border-color: var(--color-accent);
        }

        /* Export Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 200;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--color-surface);
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--color-border);
        }

        .modal-title {
            font-family: 'Literata', Georgia, serif;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .modal-subtitle {
            font-size: 14px;
            color: var(--color-text-secondary);
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--color-accent);
        }

        .form-select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: var(--color-surface);
            cursor: pointer;
        }

        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .form-checkbox input {
            width: 18px;
            height: 18px;
            accent-color: var(--color-accent);
        }

        .quality-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .quality-option {
            padding: 16px 12px;
            border: 2px solid var(--color-border);
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quality-option:hover {
            border-color: var(--color-accent);
        }

        .quality-option.selected {
            border-color: var(--color-accent);
            background: var(--color-accent-light);
        }

        .quality-name {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .quality-desc {
            font-size: 11px;
            color: var(--color-text-secondary);
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--color-border);
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .btn-secondary {
            padding: 10px 20px;
            background: var(--color-bg);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        }

        .btn-primary {
            padding: 10px 24px;
            background: var(--color-accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 14px 24px;
            background: var(--color-wood-dark);
            color: white;
            border-radius: 10px;
            font-size: 14px;
            z-index: 300;
            animation: slideIn 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: 350px;
        }

        .toast.success { background: var(--color-accent); }
        .toast.error { background: #8B3A3A; }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Loading */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            gap: 16px;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--color-border);
            border-top-color: var(--color-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Full Page Reading Mode */
        .app-container.full-page-mode .sidebar {
            display: none;
        }

        .app-container.full-page-mode .notes-panel {
            display: none;
        }

        .app-container.full-page-mode .reader-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            opacity: 0;
            transform: translateY(-100%);
            transition: opacity 0.3s, transform 0.3s;
            z-index: 20;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
        }

        .app-container.full-page-mode .reader-header:hover,
        .app-container.full-page-mode .reader-header.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .app-container.full-page-mode .main-content {
            flex: 1;
        }

        .app-container.full-page-mode .page-view {
            max-width: 900px;
            border-radius: 0;
            box-shadow: none;
        }

        .app-container.full-page-mode .page-container {
            padding: 40px 20px;
        }

        /* Full page exit button - floating */
        .exit-fullpage-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: var(--color-wood-medium);
            color: var(--color-cream);
            border: none;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            opacity: 0.3;
            transition: opacity 0.3s, transform 0.2s;
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .exit-fullpage-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .app-container.full-page-mode .exit-fullpage-btn {
            display: flex;
        }

        /* Full page toggle button style */
        .btn-icon.fullpage-btn {
            font-size: 16px;
        }

        .btn-icon.fullpage-btn.active {
            background: var(--color-accent);
            color: white;
            border-color: var(--color-accent);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar { width: 260px; }
            .notes-panel { width: 300px; }
        }

        @media (max-width: 768px) {
            .app-container { flex-direction: column; }
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 180px;
                border-right: none;
                border-bottom: 2px solid var(--color-wood-light);
            }
            .notes-panel {
                position: fixed;
                top: 0;
                right: -100%;
                width: 100%;
                height: 100%;
                z-index: 50;
                transition: right 0.3s;
            }
            .notes-panel.open { right: 0; }
            .nav-zone { width: 15%; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="app-title">üìö ReadNote Plus</div>
                <div class="app-subtitle">
                    E-Reader & Note-Taking
                    <span id="cloudIndicator" class="cloud-indicator disconnected" title="Cloud status">‚òÅ</span>
                </div>
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    + Add Book
                </button>
                <input type="file" id="fileInput" accept=".pdf,.epub,.txt" multiple>
            </div>
            <div class="sidebar-content">
                <div class="section-title">Library</div>
                <div id="fileList"></div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Reader Header -->
            <header class="reader-header" id="readerHeader" style="display: none;">
                <div class="book-info">
                    <button class="btn-icon" onclick="showLibrary()" title="Back to Library" style="margin-right: 12px; font-size: 18px;">‚Üê</button>
                    <div>
                        <div class="book-title" id="bookTitle">Book Title</div>
                        <div class="book-author" id="bookAuthor">Author</div>
                    </div>
                </div>
                <div class="reader-controls">
                    <div class="control-group" id="pageControls">
                        <button class="btn-icon" onclick="prevPage()" title="Previous">‚Äπ</button>
                        <span class="page-info" id="pageInfo">1 / 1</span>
                        <button class="btn-icon" onclick="nextPage()" title="Next">‚Ä∫</button>
                    </div>
                    <div class="control-group" id="chapterControls" style="display: none;">
                        <select id="chapterSelect" onchange="goToChapter(this.value)"></select>
                    </div>
                    <button class="btn-icon fullpage-btn" id="fullPageBtn" onclick="toggleFullPage()" title="Full Page View">‚õ∂</button>
                    <button class="btn-icon" onclick="toggleSettings()" title="Settings">‚öô</button>
                    <button class="btn" onclick="openExportModal()">Export EPUB</button>
                </div>
            </header>

            <!-- Reading Area -->
            <div class="reading-area">
                <div class="reader-panel" id="readerPanel">
                    <div class="page-container showing-library" id="pageContainer">
                        <!-- Bookshelf Library View -->
                        <div class="library-grid" id="libraryGrid">
                            <div class="library-header">
                                <h2 class="library-title">üìö Your Library</h2>
                                <p class="library-subtitle">Pull a book from the shelf to start reading</p>
                            </div>
                            <div class="bookshelf-container">
                                <div class="bookshelf" id="bookshelf">
                                    <!-- Shelves will be rendered here -->
                                </div>
                            </div>
                        </div>
                        <div class="page-view" id="pageView" style="display: none;">
                            <div class="page-content" id="pageContent"></div>
                            <div class="page-footer">
                                <span id="chapterName"></span>
                                <span id="pageNumber"></span>
                            </div>
                        </div>
                    </div>
                    <!-- Navigation Zones -->
                    <div class="nav-zone nav-zone-left" onclick="prevPage()">
                        <div class="nav-zone-icon">‚Äπ</div>
                    </div>
                    <div class="nav-zone nav-zone-right" onclick="nextPage()">
                        <div class="nav-zone-icon">‚Ä∫</div>
                    </div>
                </div>

                <!-- Notes Panel -->
                <aside class="notes-panel" id="notesPanel">
                    <div class="notes-header">
                        <span class="notes-title">üìù Notes</span>
                        <button class="toggle-notes" onclick="toggleNotes()">‚úï</button>
                    </div>
                    <div class="notes-content" id="notesContent">
                        <div class="empty-state">
                            <div class="empty-icon">‚úçÔ∏è</div>
                            <div class="empty-text">Your notes will appear here</div>
                        </div>
                    </div>
                    <div class="note-input-area">
                        <div class="input-tabs">
                            <button class="tab-btn active" onclick="switchNoteTab('text')">Write</button>
                            <button class="tab-btn" onclick="switchNoteTab('draw')">Sketch</button>
                        </div>
                        <div id="textInput" class="input-content active">
                            <textarea class="note-textarea" id="noteInput" placeholder="Write your thoughts..."></textarea>
                        </div>
                        <div id="drawInput" class="input-content">
                            <div class="canvas-toolbar">
                                <input type="color" id="brushColor" class="color-input" value="#1A1A1A">
                                <input type="number" id="brushSize" class="size-input" value="2" min="1" max="20">
                                <button class="btn" onclick="clearCanvas()" style="padding: 6px 12px; font-size: 12px;">Clear</button>
                            </div>
                            <canvas id="drawingCanvas"></canvas>
                        </div>
                        <button class="add-note-btn" onclick="addNote()">Save Note</button>
                    </div>
                </aside>
            </div>
        </main>
        <!-- Full Page Exit Button -->
        <button class="exit-fullpage-btn" id="exitFullPageBtn" onclick="toggleFullPage()" title="Exit Full Page (Esc)">‚úï</button>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <span class="settings-title">Reading Settings</span>
            <button class="close-settings" onclick="toggleSettings()">‚úï</button>
        </div>
        <div class="settings-content">
            <div class="setting-group">
                <div class="setting-label">Font Size</div>
                <div class="setting-row">
                    <input type="range" class="setting-slider" id="fontSizeSlider" min="14" max="28" value="18" onchange="updateFontSize(this.value)">
                    <span class="setting-value" id="fontSizeValue">18px</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Line Height</div>
                <div class="setting-row">
                    <input type="range" class="setting-slider" id="lineHeightSlider" min="1.4" max="2.4" step="0.1" value="1.8" onchange="updateLineHeight(this.value)">
                    <span class="setting-value" id="lineHeightValue">1.8</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Page Margins</div>
                <div class="setting-row">
                    <input type="range" class="setting-slider" id="marginSlider" min="20" max="80" value="40" onchange="updateMargins(this.value)">
                    <span class="setting-value" id="marginValue">40px</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Layout</div>
                <div class="setting-buttons">
                    <button class="setting-btn active" onclick="setLayout('single')">Single Column</button>
                    <button class="setting-btn" onclick="setLayout('two')">Two Columns</button>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Theme</div>
                <div class="setting-buttons">
                    <button class="setting-btn active" onclick="setTheme('light')">Light</button>
                    <button class="setting-btn" onclick="setTheme('sepia')">Sepia</button>
                    <button class="setting-btn" onclick="setTheme('dark')">Dark</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Export to EPUB</div>
                <div class="modal-subtitle">Create a high-quality ebook for your e-reader</div>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Book Title</label>
                    <input type="text" class="form-input" id="exportTitle" placeholder="Enter book title">
                </div>
                <div class="form-group">
                    <label class="form-label">Author</label>
                    <input type="text" class="form-input" id="exportAuthor" placeholder="Enter author name">
                </div>
                <div class="form-group">
                    <label class="form-label">Language</label>
                    <select class="form-select" id="exportLanguage">
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="it">Italian</option>
                        <option value="pt">Portuguese</option>
                        <option value="ja">Japanese</option>
                        <option value="zh">Chinese</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Export Quality</label>
                    <div class="quality-options">
                        <div class="quality-option" onclick="selectQuality('standard')">
                            <div class="quality-name">Standard</div>
                            <div class="quality-desc">Good compatibility</div>
                        </div>
                        <div class="quality-option selected" onclick="selectQuality('high')">
                            <div class="quality-name">High</div>
                            <div class="quality-desc">Best for e-readers</div>
                        </div>
                        <div class="quality-option" onclick="selectQuality('print')">
                            <div class="quality-name">Print</div>
                            <div class="quality-desc">PDF-like layout</div>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="includeNotes" checked>
                        <span>Include my notes in export</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="includeToc" checked>
                        <span>Generate table of contents</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="preserveFormatting" checked>
                        <span>Preserve original formatting</span>
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeExportModal()">Cancel</button>
                <button class="btn-primary" onclick="exportEpub()">Export EPUB</button>
            </div>
        </div>
    </div>

    <script>
        // Configure PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // State
        const state = {
            files: [],
            currentFileIndex: -1,
            notes: {},
            bookmarks: {},
            readingProgress: {},
            currentPage: 1,
            totalPages: 1,
            pdfDoc: null,
            chapters: [],
            currentChapter: 0,
            pages: [],
            pageWrapper: null,
            columnWidth: 0,
            settings: {
                fontSize: 18,
                lineHeight: 1.8,
                margin: 40,
                layout: 'single',
                theme: 'light'
            },
            exportQuality: 'high',
            fullPageMode: false,
            cloudConnected: false
        };

        // Cloud Sync API Functions
        const cloudApi = {
            async checkStatus() {
                try {
                    const response = await fetch('/api/status');
                    if (response.ok) {
                        const data = await response.json();
                        state.cloudConnected = data.redis === 'connected';
                        return state.cloudConnected;
                    }
                } catch (e) {
                    console.log('Cloud not available');
                }
                state.cloudConnected = false;
                return false;
            },

            async loadBooks() {
                if (!state.cloudConnected) return [];
                try {
                    const response = await fetch('/api/books');
                    if (response.ok) {
                        const data = await response.json();
                        return data.books || [];
                    }
                } catch (e) {
                    console.error('Failed to load books from cloud:', e);
                }
                return [];
            },

            async loadBook(bookId) {
                if (!state.cloudConnected) return null;
                try {
                    const response = await fetch(`/api/books/${encodeURIComponent(bookId)}`);
                    if (response.ok) {
                        return await response.json();
                    }
                } catch (e) {
                    console.error('Failed to load book from cloud:', e);
                }
                return null;
            },

            async saveBook(file) {
                if (!state.cloudConnected) return false;
                try {
                    // Convert ArrayBuffer to Base64 for storage
                    let rawDataBase64 = null;
                    if (file.rawData) {
                        const bytes = new Uint8Array(file.rawData);
                        let binary = '';
                        for (let i = 0; i < bytes.length; i++) {
                            binary += String.fromCharCode(bytes[i]);
                        }
                        rawDataBase64 = btoa(binary);
                    }

                    const response = await fetch('/api/books', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            id: file.name,
                            name: file.name,
                            type: file.type,
                            size: file.size,
                            metadata: file.metadata,
                            rawData: rawDataBase64,
                            content: file.content,
                            chapters: file.chapters
                        })
                    });
                    return response.ok;
                } catch (e) {
                    console.error('Failed to save book to cloud:', e);
                }
                return false;
            },

            async deleteBook(bookId) {
                if (!state.cloudConnected) return false;
                try {
                    const response = await fetch(`/api/books/${encodeURIComponent(bookId)}`, {
                        method: 'DELETE'
                    });
                    return response.ok;
                } catch (e) {
                    console.error('Failed to delete book from cloud:', e);
                }
                return false;
            },

            async loadProgress() {
                if (!state.cloudConnected) return null;
                try {
                    const response = await fetch('/api/progress');
                    if (response.ok) {
                        const data = await response.json();
                        return data.progress || {};
                    }
                } catch (e) {
                    console.error('Failed to load progress from cloud:', e);
                }
                return null;
            },

            async saveProgress(progress) {
                if (!state.cloudConnected) return false;
                try {
                    const response = await fetch('/api/progress', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ progress })
                    });
                    return response.ok;
                } catch (e) {
                    console.error('Failed to save progress to cloud:', e);
                }
                return false;
            },

            async loadNotes() {
                if (!state.cloudConnected) return null;
                try {
                    const response = await fetch('/api/notes');
                    if (response.ok) {
                        const data = await response.json();
                        return data.notes || {};
                    }
                } catch (e) {
                    console.error('Failed to load notes from cloud:', e);
                }
                return null;
            },

            async saveNotes(notes) {
                if (!state.cloudConnected) return false;
                try {
                    const response = await fetch('/api/notes', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ notes })
                    });
                    return response.ok;
                } catch (e) {
                    console.error('Failed to save notes to cloud:', e);
                }
                return false;
            }
        };

        function updateCloudIndicator() {
            const indicator = document.getElementById('cloudIndicator');
            if (indicator) {
                indicator.className = 'cloud-indicator ' + (state.cloudConnected ? 'connected' : 'disconnected');
                indicator.title = state.cloudConnected ? 'Cloud connected - syncing' : 'Cloud disconnected - local only';
            }
        }

        // Initialize
        async function init() {
            loadState();

            // Add demo books if URL has ?demo parameter
            if (window.location.search.includes('demo') && state.files.length === 0) {
                addDemoBooks();
            }

            renderFileList();
            setupKeyboardNav();
            setupTouchNav();
            setupFullPageHeaderTrigger();
            initCanvas();

            // Check cloud connection and load books from Redis
            await initCloudSync();
        }

        function addDemoBooks() {
            const demoBooks = [
                { name: 'The Great Gatsby.epub', type: 'EPUB', size: 1024000, metadata: { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald' }, content: 'Demo content...', chapters: [{ title: 'Chapter 1', content: 'In my younger and more vulnerable years...' }] },
                { name: 'Pride and Prejudice.epub', type: 'EPUB', size: 2048000, metadata: { title: 'Pride and Prejudice', author: 'Jane Austen' }, content: 'Demo content...', chapters: [{ title: 'Chapter 1', content: 'It is a truth universally acknowledged...' }] },
                { name: '1984.pdf', type: 'PDF', size: 3072000, metadata: { title: '1984', author: 'George Orwell' }, content: 'Demo content...', chapters: [{ title: 'Part One', content: 'It was a bright cold day in April...' }] },
                { name: 'To Kill a Mockingbird.epub', type: 'EPUB', size: 1536000, metadata: { title: 'To Kill a Mockingbird', author: 'Harper Lee' }, content: 'Demo content...', chapters: [{ title: 'Chapter 1', content: 'When he was nearly thirteen...' }] },
                { name: 'The Catcher in the Rye.pdf', type: 'PDF', size: 2560000, metadata: { title: 'The Catcher in the Rye', author: 'J.D. Salinger' }, content: 'Demo content...', chapters: [{ title: 'Chapter 1', content: 'If you really want to hear about it...' }] },
                { name: 'Moby Dick.epub', type: 'EPUB', size: 3584000, metadata: { title: 'Moby Dick', author: 'Herman Melville' }, content: 'Demo content...', chapters: [{ title: 'Chapter 1', content: 'Call me Ishmael...' }] },
            ];
            state.files = demoBooks;
            demoBooks.forEach(book => {
                if (!state.notes[book.name]) state.notes[book.name] = [];
            });
            console.log('Added demo books:', demoBooks.length);
        }

        async function initCloudSync() {
            const connected = await cloudApi.checkStatus();
            updateCloudIndicator();

            if (connected) {
                showToast('Cloud connected - syncing books...', 'success');

                // Load cloud progress and notes (merge with local)
                const cloudProgress = await cloudApi.loadProgress();
                const cloudNotes = await cloudApi.loadNotes();

                if (cloudProgress) {
                    state.readingProgress = { ...state.readingProgress, ...cloudProgress };
                }
                if (cloudNotes) {
                    state.notes = { ...state.notes, ...cloudNotes };
                }

                // Load book list from cloud
                const cloudBooks = await cloudApi.loadBooks();
                const localBookNames = state.files.map(f => f.name);

                // Add cloud books that aren't loaded locally
                for (const cloudBook of cloudBooks) {
                    if (!localBookNames.includes(cloudBook.name)) {
                        // Load full book data from cloud
                        const fullBook = await cloudApi.loadBook(cloudBook.id);
                        if (fullBook) {
                            const fileData = {
                                name: fullBook.name,
                                type: fullBook.type,
                                size: fullBook.size,
                                metadata: fullBook.metadata,
                                content: null,
                                chapters: []
                            };

                            // Convert Base64 back to ArrayBuffer
                            if (fullBook.rawData) {
                                const binary = atob(fullBook.rawData);
                                const bytes = new Uint8Array(binary.length);
                                for (let i = 0; i < binary.length; i++) {
                                    bytes[i] = binary.charCodeAt(i);
                                }
                                fileData.rawData = bytes.buffer;
                            }

                            // Restore content/chapters
                            if (fullBook.content) {
                                fileData.content = fullBook.content;
                            }
                            if (fullBook.chapters) {
                                fileData.chapters = fullBook.chapters;
                            }

                            state.files.push(fileData);
                            if (!state.notes[fullBook.name]) state.notes[fullBook.name] = [];
                        }
                    }
                }

                renderFileList();
                saveState();
                showToast(`Synced ${cloudBooks.length} books from cloud`, 'success');
            } else {
                console.log('Running in offline mode');
            }
        }

        function loadState() {
            try {
                const saved = localStorage.getItem('readNotePlusData');
                if (saved) {
                    const data = JSON.parse(saved);
                    state.notes = data.notes || {};
                    state.bookmarks = data.bookmarks || {};
                    state.readingProgress = data.readingProgress || {};
                    state.settings = { ...state.settings, ...data.settings };
                    applySettings();
                }

                // Load books from localStorage
                loadBooks();
            } catch (e) {
                console.error('Failed to load state:', e);
            }
        }

        // Helper functions for ArrayBuffer <-> Base64 conversion
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function loadBooks() {
            try {
                const savedBooks = localStorage.getItem('readNotePlusBooks');
                console.log('Loading books from localStorage:', savedBooks ? 'found' : 'not found');
                if (savedBooks) {
                    const books = JSON.parse(savedBooks);
                    state.files = books.map(book => ({
                        name: book.name,
                        type: book.type,
                        size: book.size,
                        metadata: book.metadata,
                        content: book.content,
                        chapters: book.chapters,
                        styles: book.styles,
                        // Convert Base64 back to ArrayBuffer
                        rawData: book.rawData ? base64ToArrayBuffer(book.rawData) : null
                    }));
                    console.log(`Loaded ${state.files.length} books from localStorage`);
                }
            } catch (e) {
                console.error('Failed to load books:', e);
            }
        }

        function saveState() {
            try {
                localStorage.setItem('readNotePlusData', JSON.stringify({
                    notes: state.notes,
                    bookmarks: state.bookmarks,
                    readingProgress: state.readingProgress,
                    settings: state.settings
                }));

                // Save books to localStorage as well (for offline persistence)
                saveBooks();

                // Also sync to cloud (debounced)
                syncToCloud();
            } catch (e) {
                console.error('Failed to save state:', e);
            }
        }

        // Save books to localStorage
        function saveBooks() {
            console.log('Saving books to localStorage, count:', state.files.length);
            if (state.files.length === 0) {
                localStorage.setItem('readNotePlusBooks', '[]');
                return;
            }

            // First try: save with rawData for small files only (< 2MB each)
            try {
                const booksToSave = state.files.map(file => {
                    const includeRawData = file.rawData && file.rawData.byteLength < 2 * 1024 * 1024;
                    return {
                        name: file.name,
                        type: file.type,
                        size: file.size,
                        metadata: file.metadata,
                        content: file.content,
                        chapters: file.chapters,
                        styles: file.styles,
                        rawData: includeRawData ? arrayBufferToBase64(file.rawData) : null
                    };
                });
                const jsonStr = JSON.stringify(booksToSave);
                console.log('Books JSON size:', (jsonStr.length / 1024 / 1024).toFixed(2), 'MB');
                localStorage.setItem('readNotePlusBooks', jsonStr);
                console.log('Books saved successfully with content');
                return;
            } catch (e) {
                console.warn('Failed to save with content, trying metadata only:', e.message);
            }

            // Second try: save without rawData but keep content/chapters
            try {
                const booksWithContent = state.files.map(file => ({
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    metadata: file.metadata,
                    content: file.content,
                    chapters: file.chapters,
                    styles: file.styles
                }));
                const jsonStr = JSON.stringify(booksWithContent);
                console.log('Books JSON size (no rawData):', (jsonStr.length / 1024 / 1024).toFixed(2), 'MB');
                localStorage.setItem('readNotePlusBooks', jsonStr);
                console.log('Books saved without rawData');
                return;
            } catch (e) {
                console.warn('Failed to save with content, trying minimal:', e.message);
            }

            // Third try: save only essential metadata (chapters truncated)
            try {
                const booksMinimal = state.files.map(file => ({
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    metadata: file.metadata,
                    // Only save first 50KB of content per book
                    content: file.content ? file.content.substring(0, 50000) : null,
                    chapters: file.chapters ? file.chapters.map(ch => ({
                        title: ch.title,
                        content: ch.content ? ch.content.substring(0, 10000) : ''
                    })) : []
                }));
                localStorage.setItem('readNotePlusBooks', JSON.stringify(booksMinimal));
                console.log('Books saved with truncated content');
                showToast('Book saved (content truncated due to size)', 'info');
                return;
            } catch (e) {
                console.error('Failed to save books:', e);
                showToast('Could not save book locally - file too large', 'error');
            }
        }

        // Debounced cloud sync for progress/notes
        let cloudSyncTimeout = null;
        function syncToCloud() {
            if (cloudSyncTimeout) clearTimeout(cloudSyncTimeout);
            cloudSyncTimeout = setTimeout(async () => {
                if (state.cloudConnected) {
                    await cloudApi.saveProgress(state.readingProgress);
                    await cloudApi.saveNotes(state.notes);
                }
            }, 2000); // Wait 2 seconds before syncing to avoid too many requests
        }

        // File handling
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            for (const file of e.target.files) {
                await loadFile(file);
            }
            e.target.value = '';
        });

        async function loadFile(file) {
            const fileData = {
                name: file.name,
                type: file.name.split('.').pop().toUpperCase(),
                size: file.size,
                content: null,
                metadata: { title: file.name.replace(/\.[^/.]+$/, ''), author: 'Unknown' }
            };

            showToast('Loading ' + file.name + '...');

            try {
                if (file.name.endsWith('.txt')) {
                    fileData.content = await readAsText(file);
                    fileData.chapters = parseTextChapters(fileData.content);
                } else if (file.name.endsWith('.pdf')) {
                    fileData.rawData = await readAsArrayBuffer(file);
                    // Extract text from PDF for EPUB export
                    showToast('Extracting text from PDF (this may take a moment)...');
                    // Create a copy of the ArrayBuffer for text extraction (PDF.js consumes the buffer)
                    const bufferCopy = fileData.rawData.slice(0);
                    const pdfExtract = await extractPdfText(bufferCopy);
                    fileData.content = pdfExtract.content;
                    fileData.chapters = pdfExtract.chapters;
                    fileData.metadata.title = file.name.replace(/\.pdf$/i, '');
                    showToast(`Extracted ${pdfExtract.chapters.length} sections from PDF`, 'success');
                } else if (file.name.endsWith('.epub')) {
                    fileData.rawData = await readAsArrayBuffer(file);
                    // Create a copy for parsing (JSZip consumes the buffer)
                    const bufferForParsing = fileData.rawData.slice(0);
                    const epub = await parseEpub(bufferForParsing);
                    fileData.content = epub.content;
                    fileData.chapters = epub.chapters;
                    fileData.metadata = epub.metadata;
                    fileData.styles = epub.styles;
                    fileData.images = epub.images;
                }

                state.files.push(fileData);
                if (!state.notes[file.name]) state.notes[file.name] = [];

                renderFileList();
                selectFile(state.files.length - 1);
                showToast('Loaded: ' + file.name, 'success');

                // Save to localStorage (and cloud if connected)
                saveState();

                // Save to cloud if connected
                if (state.cloudConnected) {
                    showToast('Saving to cloud...', 'info');
                    const saved = await cloudApi.saveBook(fileData);
                    if (saved) {
                        showToast('Book saved to cloud', 'success');
                    }
                }
            } catch (err) {
                console.error('Error loading file:', err);
                showToast('Failed to load: ' + err.message, 'error');
            }
        }

        function readAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function readAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // Extract text from PDF for EPUB export
        async function extractPdfText(arrayBuffer) {
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const numPages = pdf.numPages;
            const chapters = [];
            let fullContent = '';
            let currentChapter = { title: 'Chapter 1', content: '', pageStart: 1 };
            let chapterNum = 1;

            for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const textContent = await page.getTextContent();

                let pageText = '';
                let lastY = null;
                let lastFontSize = 0;

                // Extract text with layout awareness
                for (const item of textContent.items) {
                    if (item.str.trim() === '') continue;

                    // Add newlines for significant Y position changes (new lines)
                    if (lastY !== null && Math.abs(item.transform[5] - lastY) > 8) {
                        pageText += '\n';
                    }

                    // Detect potential chapter headings (larger font at start of section)
                    const fontSize = Math.abs(item.transform[0]);
                    if (fontSize > lastFontSize * 1.3 && fontSize > 14 &&
                        pageText.endsWith('\n') && item.str.trim().length > 0 &&
                        item.str.trim().length < 100) {
                        // Potential chapter heading detected
                        const headingText = item.str.trim();

                        // Check if it looks like a chapter heading
                        if (/^(chapter|part|section|\d+[.\s]|[ivxlcdm]+[.\s])/i.test(headingText) ||
                            (headingText.length < 60 && !headingText.includes('.'))) {

                            // Save current chapter if it has content
                            if (currentChapter.content.trim().length > 100) {
                                chapters.push({
                                    title: currentChapter.title,
                                    content: formatPdfContent(currentChapter.content)
                                });
                            }

                            chapterNum++;
                            currentChapter = {
                                title: headingText || `Chapter ${chapterNum}`,
                                content: '',
                                pageStart: pageNum
                            };
                        }
                    }

                    pageText += item.str;
                    lastY = item.transform[5];
                    lastFontSize = fontSize;
                }

                currentChapter.content += pageText + '\n\n';
                fullContent += pageText + '\n\n';

                // Add page marker for reference
                if (pageNum < numPages) {
                    currentChapter.content += `<!-- page ${pageNum} -->\n`;
                }
            }

            // Add final chapter
            if (currentChapter.content.trim().length > 0) {
                chapters.push({
                    title: currentChapter.title,
                    content: formatPdfContent(currentChapter.content)
                });
            }

            // If no chapters detected, split by page groups
            if (chapters.length <= 1 && numPages > 10) {
                const pagesPerChapter = Math.ceil(numPages / Math.min(10, Math.ceil(numPages / 20)));
                const rechaptered = [];
                let chapterContent = '';
                let chNum = 1;

                for (let i = 0; i < chapters.length; i++) {
                    const ch = chapters[i];
                    chapterContent += ch.content;
                }

                // Split by approximate page markers
                const pageMarkers = chapterContent.split(/<!-- page \d+ -->/);
                let tempContent = '';

                for (let i = 0; i < pageMarkers.length; i++) {
                    tempContent += pageMarkers[i];

                    if ((i + 1) % pagesPerChapter === 0 || i === pageMarkers.length - 1) {
                        if (tempContent.trim()) {
                            rechaptered.push({
                                title: `Section ${chNum}`,
                                content: formatPdfContent(tempContent)
                            });
                            chNum++;
                            tempContent = '';
                        }
                    }
                }

                if (rechaptered.length > 1) {
                    return { content: fullContent, chapters: rechaptered };
                }
            }

            return { content: fullContent, chapters };
        }

        function formatPdfContent(text) {
            // Clean up PDF text extraction artifacts
            return text
                .replace(/<!-- page \d+ -->/g, '') // Remove page markers
                .replace(/\n{3,}/g, '\n\n')        // Normalize multiple newlines
                .replace(/([a-z])-\n([a-z])/gi, '$1$2') // Fix hyphenated words
                .replace(/([.!?])\n([A-Z])/g, '$1\n\n$2') // Paragraph breaks after sentences
                .split('\n\n')
                .filter(p => p.trim().length > 0)
                .map(p => `<p>${escapeHtml(p.trim()).replace(/\n/g, ' ')}</p>`)
                .join('\n');
        }

        // EPUB Parser - Enhanced
        async function parseEpub(arrayBuffer) {
            const zip = await JSZip.loadAsync(arrayBuffer);

            // Find container
            const containerXml = await zip.file('META-INF/container.xml')?.async('text');
            if (!containerXml) throw new Error('Invalid EPUB');

            const parser = new DOMParser();
            const containerDoc = parser.parseFromString(containerXml, 'text/xml');
            const opfPath = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
            if (!opfPath) throw new Error('Invalid EPUB structure');

            const opfDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);

            // Parse OPF
            const opfContent = await zip.file(opfPath)?.async('text');
            const opfDoc = parser.parseFromString(opfContent, 'text/xml');

            // Metadata
            const metadata = {
                title: opfDoc.querySelector('metadata title, dc\\:title')?.textContent || 'Untitled',
                author: opfDoc.querySelector('metadata creator, dc\\:creator')?.textContent || 'Unknown',
                publisher: opfDoc.querySelector('metadata publisher, dc\\:publisher')?.textContent || '',
                language: opfDoc.querySelector('metadata language, dc\\:language')?.textContent || 'en',
                description: opfDoc.querySelector('metadata description, dc\\:description')?.textContent || '',
                date: opfDoc.querySelector('metadata date, dc\\:date')?.textContent || '',
                cover: null
            };

            // Build manifest map
            const manifestMap = {};
            opfDoc.querySelectorAll('manifest item').forEach(item => {
                manifestMap[item.getAttribute('id')] = {
                    href: item.getAttribute('href'),
                    mediaType: item.getAttribute('media-type')
                };
            });

            // Get spine order
            const spine = Array.from(opfDoc.querySelectorAll('spine itemref'));

            // Extract styles
            const styles = [];
            for (const [id, item] of Object.entries(manifestMap)) {
                if (item.mediaType === 'text/css') {
                    const cssContent = await zip.file(opfDir + item.href)?.async('text');
                    if (cssContent) styles.push(cssContent);
                }
            }

            // Extract images and find cover
            const images = {};

            // Find cover image - multiple methods
            // Method 1: Look for meta cover element
            const coverMeta = opfDoc.querySelector('metadata meta[name="cover"]');
            const coverId = coverMeta?.getAttribute('content');

            // Method 2: Look for item with cover-image property
            const coverItem = opfDoc.querySelector('manifest item[properties*="cover-image"]');

            // Method 3: Look for item with id containing 'cover'
            const coverById = Object.entries(manifestMap).find(([id, item]) =>
                id.toLowerCase().includes('cover') && item.mediaType?.startsWith('image/')
            );

            for (const [id, item] of Object.entries(manifestMap)) {
                if (item.mediaType?.startsWith('image/')) {
                    const imgData = await zip.file(opfDir + item.href)?.async('base64');
                    if (imgData) {
                        const dataUrl = `data:${item.mediaType};base64,${imgData}`;
                        images[item.href] = dataUrl;

                        // Check if this is the cover
                        if ((coverId && id === coverId) ||
                            (coverItem && item.href === coverItem.getAttribute('href')) ||
                            (coverById && id === coverById[0]) ||
                            (!metadata.cover && (
                                item.href.toLowerCase().includes('cover') ||
                                id.toLowerCase() === 'cover'
                            ))) {
                            metadata.cover = dataUrl;
                        }
                    }
                }
            }

            // Parse chapters
            const chapters = [];
            let fullContent = '';

            for (const itemref of spine) {
                const idref = itemref.getAttribute('idref');
                const item = manifestMap[idref];

                if (item && item.mediaType?.includes('html')) {
                    const chapterHtml = await zip.file(opfDir + item.href)?.async('text');
                    if (chapterHtml) {
                        const chapterDoc = parser.parseFromString(chapterHtml, 'text/html');
                        const body = chapterDoc.body;

                        if (body) {
                            // Fix image paths
                            body.querySelectorAll('img').forEach(img => {
                                const src = img.getAttribute('src');
                                if (src) {
                                    const cleanSrc = src.replace(/^\.\.\//, '').replace(/^\.\//, '');
                                    if (images[cleanSrc]) {
                                        img.setAttribute('src', images[cleanSrc]);
                                    }
                                }
                            });

                            // Get chapter title
                            const h1 = body.querySelector('h1, h2, h3');
                            const title = h1?.textContent?.trim() || `Chapter ${chapters.length + 1}`;

                            chapters.push({
                                title: title,
                                content: body.innerHTML,
                                id: `chapter-${chapters.length}`
                            });

                            fullContent += `<section id="chapter-${chapters.length - 1}" class="chapter">
                                ${body.innerHTML}
                            </section>`;
                        }
                    }
                }
            }

            return {
                content: fullContent,
                chapters: chapters,
                metadata: metadata,
                styles: styles.join('\n'),
                images: images
            };
        }

        // Text chapter detection
        function parseTextChapters(text) {
            const chapters = [];
            const lines = text.split('\n');
            let currentChapter = { title: 'Start', content: '', startLine: 0 };

            const chapterPatterns = [
                /^chapter\s+\d+/i,
                /^part\s+\d+/i,
                /^section\s+\d+/i,
                /^cap√≠tulo\s+\d+/i,
                /^\d+\.\s+/,
                /^[IVX]+\.\s+/
            ];

            lines.forEach((line, index) => {
                const trimmed = line.trim();
                const isChapterTitle = chapterPatterns.some(p => p.test(trimmed)) ||
                    (trimmed.length > 0 && trimmed.length < 60 && trimmed === trimmed.toUpperCase());

                if (isChapterTitle && currentChapter.content.trim()) {
                    chapters.push({ ...currentChapter });
                    currentChapter = { title: trimmed, content: '', startLine: index };
                } else {
                    currentChapter.content += line + '\n';
                }
            });

            if (currentChapter.content.trim()) {
                chapters.push(currentChapter);
            }

            return chapters.length > 0 ? chapters : [{ title: 'Content', content: text }];
        }

        // Render file list
        function renderFileList() {
            // Render sidebar file list
            const container = document.getElementById('fileList');
            container.innerHTML = state.files.map((file, i) => {
                const progress = state.readingProgress[file.name] || 0;
                const cover = file.metadata?.cover || file.metadata?.fetchedCover;
                const title = file.metadata?.title || file.name.replace(/\.[^/.]+$/, '');
                const author = file.metadata?.author;
                const typeIcon = file.type === 'PDF' ? 'üìÑ' : file.type === 'EPUB' ? 'üìö' : 'üìù';

                return `
                    <div class="file-item ${state.currentFileIndex === i ? 'active' : ''}" onclick="selectFile(${i})">
                        <div class="file-cover">
                            ${cover
                                ? `<img src="${cover}" alt="Cover" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'"><span style="display:none">${typeIcon}</span>`
                                : typeIcon
                            }
                        </div>
                        <div class="file-info">
                            <div class="file-name">${escapeHtml(title)}</div>
                            ${author && author !== 'Unknown' ? `<div class="file-author">${escapeHtml(author)}</div>` : ''}
                            <div class="file-meta">
                                <span class="file-size">${formatSize(file.size)}</span>
                                <span class="file-type">${file.type}</span>
                            </div>
                            ${progress > 0 ? `
                                <div class="file-progress">
                                    ${Math.round(progress)}% read
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${progress}%"></div>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            // Render library grid view
            renderLibraryGrid();
        }

        function renderLibraryGrid() {
            const bookshelf = document.getElementById('bookshelf');

            if (state.files.length === 0) {
                bookshelf.innerHTML = `
                    <div class="shelf-row">
                        <div class="empty-library">
                            <div class="empty-icon">üìö</div>
                            <div class="empty-text">Your bookshelf is empty</div>
                            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                                + Add Your First Book
                            </button>
                        </div>
                    </div>
                `;
                return;
            }

            // Group books into shelves (max 12 books per shelf)
            const booksPerShelf = 12;
            const shelves = [];
            for (let i = 0; i < state.files.length; i += booksPerShelf) {
                shelves.push(state.files.slice(i, i + booksPerShelf));
            }

            bookshelf.innerHTML = shelves.map((shelfBooks, shelfIndex) => `
                <div class="shelf-row">
                    ${shelfBooks.map((file, i) => {
                        const fileIndex = shelfIndex * booksPerShelf + i;
                        const progress = state.readingProgress[file.name] || 0;
                        const cover = file.metadata?.cover || file.metadata?.fetchedCover;
                        const title = file.metadata?.title || file.name.replace(/\.[^/.]+$/, '');
                        const author = file.metadata?.author || '';

                        return `
                            <div class="shelf-book" onclick="selectFile(${fileIndex})" title="${escapeHtml(title)}${author ? ' - ' + escapeHtml(author) : ''}">
                                <div class="book-pages"></div>
                                <div class="book-spine">
                                    <span class="book-spine-title">${escapeHtml(title)}</span>
                                    ${author && author !== 'Unknown' ? `<span class="book-spine-author">${escapeHtml(author)}</span>` : ''}
                                    ${progress > 0 ? `
                                        <div class="book-progress-bar">
                                            <div class="book-progress-fill" style="width: ${progress}%"></div>
                                        </div>
                                    ` : ''}
                                </div>
                                <div class="book-cover-3d">
                                    ${cover
                                        ? `<img src="${cover}" alt="Cover" onerror="this.parentElement.innerHTML='<div class=\\'no-cover\\'><div class=\\'no-cover-title\\'>${escapeHtml(title)}</div><div class=\\'no-cover-author\\'>${escapeHtml(author)}</div></div>'">`
                                        : `<div class="no-cover">
                                            <div class="no-cover-title">${escapeHtml(title)}</div>
                                            <div class="no-cover-author">${escapeHtml(author)}</div>
                                          </div>`
                                    }
                                </div>
                            </div>
                        `;
                    }).join('')}
                    ${shelfIndex === 0 ? '<span class="shelf-decoration left">üïØÔ∏è</span><span class="shelf-decoration right">üåø</span>' : ''}
                </div>
            `).join('');

            // Try to fetch covers for books that don't have them
            state.files.forEach((file, index) => {
                if (!file.metadata?.cover && !file.metadata?.fetchedCover && !file.metadata?.coverFetchAttempted) {
                    fetchBookCover(file, index);
                }
            });
        }

        // Fetch book cover from Open Library or Google Books API
        async function fetchBookCover(file, fileIndex) {
            const title = file.metadata?.title || file.name.replace(/\.[^/.]+$/, '');
            const author = file.metadata?.author || '';

            // Mark as attempted to avoid repeated fetches
            if (!file.metadata) file.metadata = {};
            file.metadata.coverFetchAttempted = true;

            try {
                // Try Open Library first
                const searchQuery = encodeURIComponent(`${title} ${author}`.trim());
                const openLibResponse = await fetch(`https://openlibrary.org/search.json?q=${searchQuery}&limit=1`);

                if (openLibResponse.ok) {
                    const data = await openLibResponse.json();
                    if (data.docs && data.docs.length > 0) {
                        const book = data.docs[0];
                        if (book.cover_i) {
                            const coverUrl = `https://covers.openlibrary.org/b/id/${book.cover_i}-L.jpg`;
                            file.metadata.fetchedCover = coverUrl;
                            renderLibraryGrid();
                            renderFileList();
                            saveState();
                            return;
                        }
                    }
                }

                // Fallback to Google Books API
                const googleResponse = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${searchQuery}&maxResults=1`);

                if (googleResponse.ok) {
                    const data = await googleResponse.json();
                    if (data.items && data.items.length > 0) {
                        const book = data.items[0];
                        if (book.volumeInfo?.imageLinks?.thumbnail) {
                            // Get larger image by modifying the URL
                            let coverUrl = book.volumeInfo.imageLinks.thumbnail;
                            coverUrl = coverUrl.replace('zoom=1', 'zoom=2').replace('http:', 'https:');
                            file.metadata.fetchedCover = coverUrl;
                            renderLibraryGrid();
                            renderFileList();
                            saveState();
                            return;
                        }
                    }
                }
            } catch (err) {
                console.log('Could not fetch cover for:', title, err);
            }
        }

        function showLibrary() {
            // Exit full page mode if active
            if (state.fullPageMode) {
                state.fullPageMode = false;
                document.querySelector('.app-container').classList.remove('full-page-mode');
                document.getElementById('fullPageBtn').classList.remove('active');
            }

            state.currentFileIndex = -1;
            document.getElementById('readerHeader').style.display = 'none';
            document.getElementById('libraryGrid').style.display = 'block';
            document.getElementById('pageView').style.display = 'none';
            document.getElementById('pageContainer').classList.add('showing-library');
            renderFileList();
        }

        // Select and display file
        async function selectFile(index) {
            state.currentFileIndex = index;
            const file = state.files[index];

            document.getElementById('readerHeader').style.display = 'flex';
            document.getElementById('libraryGrid').style.display = 'none';
            document.getElementById('pageView').style.display = 'flex';
            document.getElementById('pageContainer').classList.remove('showing-library');

            document.getElementById('bookTitle').textContent = file.metadata?.title || file.name;
            document.getElementById('bookAuthor').textContent = file.metadata?.author || '';

            // Build chapter select
            if (file.chapters && file.chapters.length > 1) {
                document.getElementById('chapterControls').style.display = 'block';
                const select = document.getElementById('chapterSelect');
                select.innerHTML = file.chapters.map((ch, i) =>
                    `<option value="${i}">${escapeHtml(ch.title)}</option>`
                ).join('');
            } else {
                document.getElementById('chapterControls').style.display = 'none';
            }

            // Wait for container to be laid out before rendering
            await new Promise(resolve => {
                requestAnimationFrame(() => {
                    requestAnimationFrame(resolve);
                });
            });

            if (file.type === 'PDF') {
                // Create a copy of the buffer (PDF.js may consume it)
                const bufferCopy = file.rawData.slice(0);
                await renderPdf(bufferCopy);
            } else {
                await renderBook(file);
            }

            // Restore reading position
            const savedProgress = state.readingProgress[file.name];
            if (savedProgress) {
                const targetPage = Math.floor((savedProgress / 100) * state.totalPages);
                if (targetPage > 1) goToPage(targetPage);
            }

            renderNotes();
            renderFileList();
        }

        // PDF Rendering
        async function renderPdf(data) {
            try {
                showToast('Loading PDF...');
                state.pdfDoc = await pdfjsLib.getDocument({ data }).promise;
                state.totalPages = state.pdfDoc.numPages;
                state.currentPage = 1;
                state.pages = null; // Clear text pages
                state.pageWrapper = null;

                // Wait for container to have proper dimensions
                const container = document.getElementById('pageContent');
                let attempts = 0;
                while (container.clientWidth <= 0 && attempts < 20) {
                    await new Promise(r => setTimeout(r, 50));
                    attempts++;
                }

                await renderPdfPage(state.currentPage);
                showToast(`PDF loaded: ${state.totalPages} pages`, 'success');
            } catch (err) {
                console.error('PDF load error:', err);
                showToast('Failed to load PDF: ' + err.message, 'error');
            }
        }

        async function renderPdfPage(pageNum) {
            if (!state.pdfDoc) return;

            try {
                const page = await state.pdfDoc.getPage(pageNum);
                const container = document.getElementById('pageContent');

                // Get container dimensions
                let containerWidth = container.clientWidth;
                let containerHeight = container.clientHeight;

                // Use reasonable defaults if container not ready
                if (containerWidth <= 0) containerWidth = 700;
                if (containerHeight <= 0) containerHeight = 900;

                // Account for padding
                const padding = state.settings.margin;
                const availableWidth = containerWidth - (padding * 2);
                const availableHeight = containerHeight - (padding * 2);

                const viewport = page.getViewport({ scale: 1 });

                // Calculate scale to fit within available space
                const scaleWidth = availableWidth / viewport.width;
                const scaleHeight = availableHeight / viewport.height;
                const scale = Math.min(scaleWidth, scaleHeight, 2); // Cap at 2x for quality

                const scaledViewport = page.getViewport({ scale });

                // Create high-DPI canvas for crisp rendering
                const canvas = document.createElement('canvas');
                const pixelRatio = window.devicePixelRatio || 1;
                canvas.width = scaledViewport.width * pixelRatio;
                canvas.height = scaledViewport.height * pixelRatio;
                canvas.style.width = scaledViewport.width + 'px';
                canvas.style.height = scaledViewport.height + 'px';

                const ctx = canvas.getContext('2d');
                ctx.scale(pixelRatio, pixelRatio);

                await page.render({
                    canvasContext: ctx,
                    viewport: scaledViewport
                }).promise;

                container.innerHTML = '';
                container.appendChild(canvas);

                state.currentPage = pageNum;
                updatePageInfo();
                updateReadingProgress();
            } catch (err) {
                console.error('PDF page render error:', err);
                showToast('Failed to render page: ' + err.message, 'error');
            }
        }

        // Book rendering with pagination
        async function renderBook(file) {
            state.pdfDoc = null;

            // Prepare content
            let html = '';
            if (file.chapters) {
                html = file.chapters.map((ch, i) => `
                    <section id="chapter-${i}" class="chapter">
                        <h2>${escapeHtml(ch.title)}</h2>
                        ${ch.content.includes('<') ? ch.content : formatText(ch.content)}
                    </section>
                `).join('<div class="chapter-break"></div>');
            } else {
                html = file.content.includes('<') ? file.content : formatText(file.content);
            }

            // Calculate pages
            await paginateContent(html);
        }

        function formatText(text) {
            return text.split('\n\n')
                .map(p => p.trim())
                .filter(p => p)
                .map(p => `<p>${escapeHtml(p).replace(/\n/g, '<br>')}</p>`)
                .join('');
        }

        async function paginateContent(html) {
            const container = document.getElementById('pageContent');
            const pageHeight = container.clientHeight - (state.settings.margin * 2);
            const pageWidth = container.clientWidth - (state.settings.margin * 2);

            // Create a measuring container
            const measureDiv = document.createElement('div');
            measureDiv.style.cssText = `
                position: absolute;
                visibility: hidden;
                width: ${pageWidth}px;
                font-family: 'Literata', Georgia, serif;
                font-size: ${state.settings.fontSize}px;
                line-height: ${state.settings.lineHeight};
                text-align: justify;
            `;
            measureDiv.innerHTML = html;
            document.body.appendChild(measureDiv);

            // Wait for layout
            await new Promise(r => requestAnimationFrame(r));

            // Split content into pages based on actual rendered height
            state.pages = [];
            const allElements = Array.from(measureDiv.querySelectorAll('p, h1, h2, h3, h4, section, div, blockquote, img'));

            // If no block elements found, wrap content in paragraphs
            if (allElements.length === 0) {
                const textContent = measureDiv.textContent || measureDiv.innerText;
                const paragraphs = textContent.split(/\n\n+/).filter(p => p.trim());
                measureDiv.innerHTML = paragraphs.map(p => `<p>${escapeHtml(p)}</p>`).join('');
                await new Promise(r => requestAnimationFrame(r));
                allElements.push(...measureDiv.querySelectorAll('p'));
            }

            let currentPageHtml = '';
            let currentHeight = 0;

            // Create a test container for accurate height measurement
            const testDiv = document.createElement('div');
            testDiv.style.cssText = measureDiv.style.cssText;
            document.body.appendChild(testDiv);

            for (const el of allElements) {
                // Clone element for measurement
                testDiv.innerHTML = currentPageHtml + el.outerHTML;
                await new Promise(r => requestAnimationFrame(r));

                const testHeight = testDiv.scrollHeight;

                if (testHeight > pageHeight && currentPageHtml) {
                    // Current element would overflow, save current page
                    state.pages.push(currentPageHtml);
                    currentPageHtml = el.outerHTML;
                } else {
                    currentPageHtml += el.outerHTML;
                }
            }

            // Add remaining content as last page
            if (currentPageHtml.trim()) {
                state.pages.push(currentPageHtml);
            }

            // Cleanup
            document.body.removeChild(measureDiv);
            document.body.removeChild(testDiv);

            // Ensure at least one page
            if (state.pages.length === 0) {
                state.pages.push(html);
            }

            state.totalPages = state.pages.length;
            state.currentPage = 1;
            state.pageWrapper = null;

            displayPage(1);
        }

        async function displayPage(pageNum) {
            const container = document.getElementById('pageContent');

            if (state.pdfDoc) {
                await renderPdfPage(pageNum);
                return; // renderPdfPage handles state updates
            } else if (state.pages && state.pages[pageNum - 1] !== undefined) {
                container.innerHTML = `<div class="page-text-content">${state.pages[pageNum - 1]}</div>`;
            }

            state.currentPage = pageNum;
            updatePageInfo();
            updateReadingProgress();
        }

        function updatePageInfo() {
            document.getElementById('pageInfo').textContent = `${state.currentPage} / ${state.totalPages}`;
            document.getElementById('pageNumber').textContent = `Page ${state.currentPage} of ${state.totalPages}`;

            // Update chapter name
            const file = state.files[state.currentFileIndex];
            if (file?.chapters) {
                // Find current chapter based on page
                const chapterIndex = Math.min(
                    Math.floor((state.currentPage / state.totalPages) * file.chapters.length),
                    file.chapters.length - 1
                );
                document.getElementById('chapterName').textContent = file.chapters[chapterIndex]?.title || '';
            }
        }

        function updateReadingProgress() {
            if (state.currentFileIndex >= 0) {
                const file = state.files[state.currentFileIndex];
                const progress = (state.currentPage / state.totalPages) * 100;
                state.readingProgress[file.name] = progress;
                saveState();
            }
        }

        // Navigation
        function prevPage() {
            if (state.currentPage > 1) {
                displayPage(state.currentPage - 1);
            }
        }

        function nextPage() {
            if (state.currentPage < state.totalPages) {
                displayPage(state.currentPage + 1);
            }
        }

        function goToPage(page) {
            if (page >= 1 && page <= state.totalPages) {
                displayPage(page);
            }
        }

        function goToChapter(index) {
            const file = state.files[state.currentFileIndex];
            if (file?.chapters) {
                const chaptersPerPage = state.totalPages / file.chapters.length;
                const targetPage = Math.floor(index * chaptersPerPage) + 1;
                goToPage(targetPage);
            }
        }

        // Keyboard navigation
        function setupKeyboardNav() {
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch(e.key) {
                    case 'ArrowLeft':
                    case 'PageUp':
                        e.preventDefault();
                        prevPage();
                        break;
                    case 'ArrowRight':
                    case 'PageDown':
                    case ' ':
                        e.preventDefault();
                        nextPage();
                        break;
                    case 'Home':
                        e.preventDefault();
                        goToPage(1);
                        break;
                    case 'End':
                        e.preventDefault();
                        goToPage(state.totalPages);
                        break;
                    case 'Escape':
                        if (state.fullPageMode) {
                            e.preventDefault();
                            toggleFullPage();
                        }
                        break;
                    case 'f':
                    case 'F':
                        if (state.currentFileIndex >= 0) {
                            e.preventDefault();
                            toggleFullPage();
                        }
                        break;
                }
            });
        }

        // Touch navigation
        function setupTouchNav() {
            let touchStartX = 0;
            const container = document.getElementById('pageContainer');

            container.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
            }, { passive: true });

            container.addEventListener('touchend', (e) => {
                const touchEndX = e.changedTouches[0].screenX;
                const diff = touchStartX - touchEndX;

                if (Math.abs(diff) > 50) {
                    if (diff > 0) nextPage();
                    else prevPage();
                }
            }, { passive: true });
        }

        // Settings
        function toggleSettings() {
            document.getElementById('settingsPanel').classList.toggle('open');
        }

        function updateFontSize(value) {
            state.settings.fontSize = parseInt(value);
            document.getElementById('fontSizeValue').textContent = value + 'px';
            document.documentElement.style.setProperty('--font-size', value + 'px');
            saveState();
            if (state.currentFileIndex >= 0) {
                const file = state.files[state.currentFileIndex];
                if (file.type !== 'PDF') renderBook(file);
            }
        }

        function updateLineHeight(value) {
            state.settings.lineHeight = parseFloat(value);
            document.getElementById('lineHeightValue').textContent = value;
            document.documentElement.style.setProperty('--line-height', value);
            saveState();
            if (state.currentFileIndex >= 0) {
                const file = state.files[state.currentFileIndex];
                if (file.type !== 'PDF') renderBook(file);
            }
        }

        function updateMargins(value) {
            state.settings.margin = parseInt(value);
            document.getElementById('marginValue').textContent = value + 'px';
            document.documentElement.style.setProperty('--page-margin', value + 'px');
            saveState();
            if (state.currentFileIndex >= 0) {
                const file = state.files[state.currentFileIndex];
                if (file.type !== 'PDF') renderBook(file);
            }
        }

        function setLayout(layout) {
            state.settings.layout = layout;
            document.querySelectorAll('.setting-group:nth-child(4) .setting-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase().includes(layout));
            });
            const content = document.getElementById('pageContent');
            content.classList.toggle('two-columns', layout === 'two');
            saveState();
        }

        function setTheme(theme) {
            state.settings.theme = theme;
            document.querySelectorAll('.setting-group:nth-child(5) .setting-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase() === theme);
            });

            const root = document.documentElement;
            switch(theme) {
                case 'sepia':
                    root.style.setProperty('--color-bg', '#F4ECD8');
                    root.style.setProperty('--color-surface', '#FDF8F0');
                    root.style.setProperty('--color-text', '#5C4B37');
                    break;
                case 'dark':
                    root.style.setProperty('--color-bg', '#1A1A1A');
                    root.style.setProperty('--color-surface', '#2D2D2D');
                    root.style.setProperty('--color-text', '#E0E0E0');
                    break;
                default:
                    root.style.setProperty('--color-bg', '#FAFAF8');
                    root.style.setProperty('--color-surface', '#FFFFFF');
                    root.style.setProperty('--color-text', '#1A1A1A');
            }
            saveState();
        }

        function applySettings() {
            document.getElementById('fontSizeSlider').value = state.settings.fontSize;
            document.getElementById('fontSizeValue').textContent = state.settings.fontSize + 'px';
            document.getElementById('lineHeightSlider').value = state.settings.lineHeight;
            document.getElementById('lineHeightValue').textContent = state.settings.lineHeight;
            document.getElementById('marginSlider').value = state.settings.margin;
            document.getElementById('marginValue').textContent = state.settings.margin + 'px';

            updateFontSize(state.settings.fontSize);
            updateLineHeight(state.settings.lineHeight);
            updateMargins(state.settings.margin);
            setLayout(state.settings.layout);
            setTheme(state.settings.theme);
        }

        // Notes
        function toggleNotes() {
            document.getElementById('notesPanel').classList.toggle('open');
        }

        // Full Page Mode
        let headerTimeout = null;

        function setupFullPageHeaderTrigger() {
            document.addEventListener('mousemove', (e) => {
                if (!state.fullPageMode) return;

                const header = document.getElementById('readerHeader');
                if (e.clientY < 60) {
                    header.classList.add('visible');
                    if (headerTimeout) clearTimeout(headerTimeout);
                } else if (e.clientY > 120) {
                    if (headerTimeout) clearTimeout(headerTimeout);
                    headerTimeout = setTimeout(() => {
                        header.classList.remove('visible');
                    }, 500);
                }
            });
        }

        function toggleFullPage() {
            state.fullPageMode = !state.fullPageMode;
            const container = document.querySelector('.app-container');
            const btn = document.getElementById('fullPageBtn');

            if (state.fullPageMode) {
                container.classList.add('full-page-mode');
                btn.classList.add('active');
                btn.title = 'Exit Full Page (Esc)';
                showToast('Full page mode - Press F or Esc to exit', 'success');

                // Re-render content to adjust to new size
                setTimeout(() => {
                    if (state.currentFileIndex >= 0) {
                        const file = state.files[state.currentFileIndex];
                        if (file.type === 'PDF') {
                            renderPdfPage(state.currentPage);
                        } else if (state.pages && state.pages.length > 0) {
                            renderTextPage(state.currentPage);
                        }
                    }
                }, 300);
            } else {
                container.classList.remove('full-page-mode');
                btn.classList.remove('active');
                btn.title = 'Full Page View';

                // Re-render content to adjust to new size
                setTimeout(() => {
                    if (state.currentFileIndex >= 0) {
                        const file = state.files[state.currentFileIndex];
                        if (file.type === 'PDF') {
                            renderPdfPage(state.currentPage);
                        } else if (state.pages && state.pages.length > 0) {
                            renderTextPage(state.currentPage);
                        }
                    }
                }, 300);
            }
        }

        function switchNoteTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.input-content').forEach(el => el.classList.remove('active'));

            if (tab === 'text') {
                document.querySelectorAll('.tab-btn')[0].classList.add('active');
                document.getElementById('textInput').classList.add('active');
            } else {
                document.querySelectorAll('.tab-btn')[1].classList.add('active');
                document.getElementById('drawInput').classList.add('active');
                setTimeout(initCanvas, 50);
            }
        }

        function addNote() {
            if (state.currentFileIndex < 0) {
                showToast('Please open a book first', 'error');
                return;
            }

            const file = state.files[state.currentFileIndex];
            const isDrawing = document.getElementById('drawInput').classList.contains('active');
            let noteData;

            if (isDrawing) {
                const canvas = document.getElementById('drawingCanvas');
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const hasContent = imageData.data.some((v, i) => i % 4 === 3 && v > 0);

                if (!hasContent) {
                    showToast('Please draw something first', 'error');
                    return;
                }

                noteData = { type: 'drawing', content: canvas.toDataURL() };
                clearCanvas();
            } else {
                const text = document.getElementById('noteInput').value.trim();
                if (!text) {
                    showToast('Please enter some text', 'error');
                    return;
                }
                noteData = { type: 'text', content: text };
                document.getElementById('noteInput').value = '';
            }

            if (!state.notes[file.name]) state.notes[file.name] = [];
            state.notes[file.name].push({
                id: Date.now(),
                data: noteData,
                page: state.currentPage,
                timestamp: new Date().toLocaleString()
            });

            renderNotes();
            saveState();
            showToast('Note saved', 'success');
        }

        function renderNotes() {
            const container = document.getElementById('notesContent');
            if (state.currentFileIndex < 0) return;

            const file = state.files[state.currentFileIndex];
            const notes = state.notes[file.name] || [];

            if (notes.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">‚úçÔ∏è</div>
                        <div class="empty-text">Your notes will appear here</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = notes.map(note => `
                <div class="note-item">
                    <button class="delete-note" onclick="deleteNote(${note.id})">√ó</button>
                    <span class="note-page">Page ${note.page}</span>
                    ${note.data.type === 'text'
                        ? `<div class="note-text">${escapeHtml(note.data.content)}</div>`
                        : `<img src="${note.data.content}" class="note-drawing" alt="Note">`
                    }
                    <div class="note-time">${note.timestamp}</div>
                </div>
            `).join('');
        }

        function deleteNote(id) {
            const file = state.files[state.currentFileIndex];
            state.notes[file.name] = state.notes[file.name].filter(n => n.id !== id);
            renderNotes();
            saveState();
        }

        // Canvas
        let canvas, ctx, isDrawing = false;

        function initCanvas() {
            canvas = document.getElementById('drawingCanvas');
            if (!canvas) return;

            ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            ctx.scale(devicePixelRatio, devicePixelRatio);

            canvas.onpointerdown = startDraw;
            canvas.onpointermove = draw;
            canvas.onpointerup = canvas.onpointerleave = stopDraw;
        }

        function startDraw(e) {
            isDrawing = true;
            ctx.beginPath();
            ctx.moveTo(e.offsetX, e.offsetY);
        }

        function draw(e) {
            if (!isDrawing) return;
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.strokeStyle = document.getElementById('brushColor').value;
            ctx.lineWidth = (parseInt(document.getElementById('brushSize').value) || 2) * (e.pressure || 0.5);
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(e.offsetX, e.offsetY);
        }

        function stopDraw() {
            isDrawing = false;
        }

        function clearCanvas() {
            if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Export Modal
        function openExportModal() {
            if (state.currentFileIndex < 0) {
                showToast('Please open a book first', 'error');
                return;
            }

            const file = state.files[state.currentFileIndex];
            document.getElementById('exportTitle').value = file.metadata?.title || file.name.replace(/\.[^/.]+$/, '');
            document.getElementById('exportAuthor').value = file.metadata?.author || '';
            document.getElementById('exportLanguage').value = file.metadata?.language || 'en';

            document.getElementById('exportModal').classList.add('active');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('active');
        }

        function selectQuality(quality) {
            state.exportQuality = quality;
            document.querySelectorAll('.quality-option').forEach(opt => {
                opt.classList.toggle('selected', opt.onclick.toString().includes(quality));
            });
        }

        // EPUB Export - Professional Quality
        async function exportEpub() {
            const file = state.files[state.currentFileIndex];
            const title = document.getElementById('exportTitle').value || 'Untitled';
            const author = document.getElementById('exportAuthor').value || 'Unknown';
            const language = document.getElementById('exportLanguage').value;
            const includeNotes = document.getElementById('includeNotes').checked;
            const includeToc = document.getElementById('includeToc').checked;
            const preserveFormatting = document.getElementById('preserveFormatting').checked;

            showToast('Creating EPUB...');

            try {
                const zip = new JSZip();
                const uuid = 'urn:uuid:' + crypto.randomUUID();
                const timestamp = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');

                // mimetype (uncompressed, first file)
                zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' });

                // META-INF/container.xml
                zip.file('META-INF/container.xml', `<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`);

                // Build chapters
                const chapters = file.chapters || [{ title: 'Content', content: file.content }];
                const notes = includeNotes ? (state.notes[file.name] || []) : [];

                // Get original cover if available
                const originalCover = file.metadata?.cover;
                let coverManifest = '';
                let coverMeta = '';

                if (originalCover) {
                    // Extract image type from data URL
                    const coverMatch = originalCover.match(/^data:image\/(jpeg|png|gif|webp);base64,(.+)$/);
                    if (coverMatch) {
                        const coverType = coverMatch[1] === 'jpeg' ? 'jpg' : coverMatch[1];
                        const coverData = coverMatch[2];
                        const coverMime = `image/${coverMatch[1]}`;

                        // Add cover image to EPUB
                        zip.file(`OEBPS/images/cover.${coverType}`, coverData, { base64: true });

                        coverManifest = `
    <item id="cover-image" href="images/cover.${coverType}" media-type="${coverMime}" properties="cover-image"/>
    <item id="cover" href="cover.xhtml" media-type="application/xhtml+xml"/>`;
                        coverMeta = `
    <meta name="cover" content="cover-image"/>`;

                        // Create cover page
                        zip.file('OEBPS/cover.xhtml', `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="${language}">
<head>
  <meta charset="UTF-8"/>
  <title>Cover</title>
  <style>
    body { margin: 0; padding: 0; text-align: center; }
    img { max-width: 100%; max-height: 100vh; }
  </style>
</head>
<body>
  <img src="images/cover.${coverType}" alt="Cover"/>
</body>
</html>`);
                    }
                }

                // Generate manifest and spine
                let manifestItems = `
    <item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>
    <item id="css" href="styles.css" media-type="text/css"/>${coverManifest}`;

                let spineItems = originalCover ? `
    <itemref idref="cover"/>` : '';

                chapters.forEach((ch, i) => {
                    manifestItems += `
    <item id="chapter${i}" href="chapter${i}.xhtml" media-type="application/xhtml+xml"/>`;
                    spineItems += `
    <itemref idref="chapter${i}"/>`;
                });

                if (notes.length > 0) {
                    manifestItems += `
    <item id="notes" href="notes.xhtml" media-type="application/xhtml+xml"/>`;
                    spineItems += `
    <itemref idref="notes"/>`;
                }

                // OEBPS/content.opf
                zip.file('OEBPS/content.opf', `<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" version="3.0" unique-identifier="uid">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
    <dc:identifier id="uid">${uuid}</dc:identifier>
    <dc:title>${escapeXml(title)}</dc:title>
    <dc:creator>${escapeXml(author)}</dc:creator>
    <dc:language>${language}</dc:language>
    <dc:date>${timestamp}</dc:date>
    <meta property="dcterms:modified">${timestamp}</meta>
    <meta name="generator" content="ReadNote Plus"/>
  </metadata>
  <manifest>${manifestItems}
  </manifest>
  <spine>${spineItems}
  </spine>
</package>`);

                // Navigation document
                let navContent = chapters.map((ch, i) =>
                    `      <li><a href="chapter${i}.xhtml">${escapeXml(ch.title)}</a></li>`
                ).join('\n');

                if (notes.length > 0) {
                    navContent += `\n      <li><a href="notes.xhtml">Notes</a></li>`;
                }

                zip.file('OEBPS/nav.xhtml', `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="${language}">
<head>
  <meta charset="UTF-8"/>
  <title>Table of Contents</title>
  <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
  <nav epub:type="toc" id="toc">
    <h1>Table of Contents</h1>
    <ol>
${navContent}
    </ol>
  </nav>
</body>
</html>`);

                // Styles optimized for e-readers
                const cssQuality = {
                    standard: `
body { margin: 1em; font-family: serif; line-height: 1.5; }
h1, h2, h3 { margin: 1em 0 0.5em; }
p { margin: 0 0 0.8em; text-indent: 1.5em; text-align: justify; }
p:first-of-type { text-indent: 0; }
img { max-width: 100%; height: auto; }`,
                    high: `
@page { margin: 2cm; }
body {
  font-family: "Literata", "Georgia", "Times New Roman", serif;
  font-size: 1em;
  line-height: 1.8;
  margin: 0;
  padding: 1.5em;
  text-rendering: optimizeLegibility;
  -webkit-hyphens: auto;
  hyphens: auto;
  orphans: 2;
  widows: 2;
}
h1 {
  font-size: 2em;
  text-align: center;
  margin: 2em 0 1em;
  page-break-after: avoid;
  line-height: 1.2;
}
h2 {
  font-size: 1.5em;
  margin: 1.5em 0 0.5em;
  page-break-after: avoid;
  border-bottom: 1px solid #ccc;
  padding-bottom: 0.3em;
}
h3 {
  font-size: 1.2em;
  margin: 1.2em 0 0.4em;
  page-break-after: avoid;
}
p {
  margin: 0 0 1em;
  text-indent: 1.5em;
  text-align: justify;
}
p:first-of-type,
h1 + p, h2 + p, h3 + p {
  text-indent: 0;
}
p:first-of-type::first-letter {
  font-size: 3em;
  float: left;
  line-height: 1;
  margin-right: 0.1em;
  font-weight: bold;
}
blockquote {
  margin: 1em 2em;
  padding-left: 1em;
  border-left: 3px solid #666;
  font-style: italic;
}
img {
  max-width: 100%;
  height: auto;
  display: block;
  margin: 1em auto;
  page-break-inside: avoid;
}
.chapter { page-break-before: always; }
.note {
  background: #f5f5f5;
  padding: 1em;
  margin: 1em 0;
  border-left: 4px solid #2D5016;
  border-radius: 4px;
}
.note-text { font-style: italic; }
.note-meta { font-size: 0.85em; color: #666; margin-top: 0.5em; }
.note-drawing { max-width: 100%; border: 1px solid #ddd; border-radius: 4px; }`,
                    print: `
@page {
  margin: 2.5cm;
  @bottom-center { content: counter(page); }
}
body {
  font-family: "Literata", "Palatino", serif;
  font-size: 11pt;
  line-height: 1.6;
  text-align: justify;
  -webkit-hyphens: auto;
  hyphens: auto;
}
h1 {
  font-size: 24pt;
  text-align: center;
  margin: 3em 0 2em;
  page-break-before: always;
}
h2 { font-size: 16pt; margin: 2em 0 1em; }
p { margin: 0 0 0.5em; text-indent: 2em; }
p:first-of-type { text-indent: 0; }
img { max-width: 100%; page-break-inside: avoid; }`
                };

                zip.file('OEBPS/styles.css', cssQuality[state.exportQuality] || cssQuality.high);

                // Chapter files
                for (let i = 0; i < chapters.length; i++) {
                    const ch = chapters[i];
                    let chapterContent = ch.content;

                    // Convert plain text to HTML if needed
                    if (!chapterContent.includes('<')) {
                        chapterContent = chapterContent.split('\n\n')
                            .map(p => p.trim())
                            .filter(p => p)
                            .map(p => `<p>${escapeXml(p).replace(/\n/g, '<br/>')}</p>`)
                            .join('\n');
                    }

                    zip.file(`OEBPS/chapter${i}.xhtml`, `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="${language}">
<head>
  <meta charset="UTF-8"/>
  <title>${escapeXml(ch.title)}</title>
  <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
  <section class="chapter" epub:type="chapter">
    <h1>${escapeXml(ch.title)}</h1>
    ${chapterContent}
  </section>
</body>
</html>`);
                }

                // Notes file
                if (notes.length > 0) {
                    let notesHtml = notes.map((note, i) => {
                        if (note.data.type === 'text') {
                            return `<div class="note">
      <p class="note-text">"${escapeXml(note.data.content)}"</p>
      <p class="note-meta">Page ${note.page} ‚Ä¢ ${note.timestamp}</p>
    </div>`;
                        } else {
                            // Save image and reference it
                            const imgName = `note_${i}.png`;
                            const imgData = note.data.content.split(',')[1];
                            zip.file(`OEBPS/images/${imgName}`, imgData, { base64: true });
                            return `<div class="note">
      <img class="note-drawing" src="images/${imgName}" alt="Note sketch"/>
      <p class="note-meta">Page ${note.page} ‚Ä¢ ${note.timestamp}</p>
    </div>`;
                        }
                    }).join('\n');

                    zip.file('OEBPS/notes.xhtml', `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="${language}">
<head>
  <meta charset="UTF-8"/>
  <title>Notes</title>
  <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
  <section class="chapter">
    <h1>Reading Notes</h1>
    <p><em>Notes for: ${escapeXml(title)}</em></p>
    ${notesHtml}
  </section>
</body>
</html>`);
                }

                // Generate EPUB
                const blob = await zip.generateAsync({
                    type: 'blob',
                    mimeType: 'application/epub+zip',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 9 }
                });

                // Download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${title}.epub`;
                a.click();

                // Add exported EPUB to library automatically
                const arrayBuffer = await blob.arrayBuffer();
                const exportedFile = {
                    name: `${title}.epub`,
                    type: 'EPUB',
                    size: blob.size,
                    rawData: arrayBuffer.slice(0), // Keep a copy for later use
                    content: null,
                    chapters: chapters,
                    metadata: {
                        title: title,
                        author: author,
                        language: language,
                        cover: file.metadata?.cover || null // Preserve original cover
                    }
                };

                // Parse the exported EPUB to get full content (use a copy)
                try {
                    const bufferForParsing = arrayBuffer.slice(0);
                    const parsedEpub = await parseEpub(bufferForParsing);
                    exportedFile.content = parsedEpub.content;
                    exportedFile.chapters = parsedEpub.chapters;
                    // Keep the original cover if the new one wasn't found
                    if (!parsedEpub.metadata.cover && file.metadata?.cover) {
                        exportedFile.metadata.cover = file.metadata.cover;
                    } else if (parsedEpub.metadata.cover) {
                        exportedFile.metadata.cover = parsedEpub.metadata.cover;
                    }
                } catch (e) {
                    console.log('Could not parse exported EPUB, using original data');
                    exportedFile.content = file.content;
                }

                // Check if already in library (by name)
                const existingIndex = state.files.findIndex(f => f.name === exportedFile.name);
                if (existingIndex >= 0) {
                    state.files[existingIndex] = exportedFile;
                } else {
                    state.files.push(exportedFile);
                }

                if (!state.notes[exportedFile.name]) {
                    state.notes[exportedFile.name] = notes;
                }

                renderFileList();
                URL.revokeObjectURL(url);

                closeExportModal();
                showToast('EPUB exported and added to library!', 'success');

            } catch (err) {
                console.error('Export error:', err);
                showToast('Export failed: ' + err.message, 'error');
            }
        }

        // Utilities
        function escapeHtml(str) {
            if (!str) return '';
            return String(str).replace(/[&<>"']/g, c => ({
                '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'
            }[c]));
        }

        function escapeXml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        async function deleteFile(index) {
            const file = state.files[index];
            state.files.splice(index, 1);
            if (state.currentFileIndex === index) {
                showLibrary();
            } else if (state.currentFileIndex > index) {
                state.currentFileIndex--;
            }
            renderFileList();

            // Save to localStorage
            saveState();

            // Delete from cloud if connected
            if (state.cloudConnected && file) {
                await cloudApi.deleteBook(file.name);
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Initialize app
        init();
    </script>
</body>
</html>
