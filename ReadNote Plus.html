<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ReadNote Plus - E-Reader & Note-Taking</title>
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- JSZip for EPUB -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Google Fonts - Optimized for e-ink -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Literata:ital,opsz,wght@0,7..72,400;0,7..72,500;0,7..72,600;1,7..72,400&family=Source+Sans+3:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            /* E-ink optimized colors */
            --color-bg: #FAFAF8;
            --color-surface: #FFFFFF;
            --color-text: #1A1A1A;
            --color-text-secondary: #4A4A4A;
            --color-accent: #2D5016;
            --color-accent-light: #E8F0E4;
            --color-border: #D0D0D0;
            --color-highlight: #FFF3CD;

            /* Cozy palette */
            --color-wood-dark: #3D2314;
            --color-wood-medium: #5C3D2E;
            --color-wood-light: #8B5A2B;
            --color-cream: #F5E6D3;
            --color-parchment: #FDF8F0;
            --color-ember: #C65D3B;
            --color-amber: #D4A574;

            /* Reading settings */
            --font-size: 18px;
            --line-height: 1.8;
            --page-margin: 40px;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Source Sans 3', -apple-system, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            line-height: 1.5;
            min-height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: linear-gradient(180deg, var(--color-wood-medium) 0%, var(--color-wood-dark) 100%);
            border-right: 3px solid var(--color-wood-light);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
        }

        .app-title {
            font-family: 'Literata', Georgia, serif;
            font-size: 22px;
            font-weight: 600;
            color: var(--color-cream);
            margin-bottom: 4px;
        }

        .app-subtitle {
            font-size: 12px;
            color: var(--color-amber);
            opacity: 0.9;
        }

        .upload-btn {
            width: 100%;
            padding: 14px;
            margin-top: 16px;
            background: linear-gradient(135deg, var(--color-ember) 0%, #E8854A 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(198, 93, 59, 0.4);
        }

        #fileInput {
            display: none;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--color-amber);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(212, 165, 116, 0.3);
        }

        .file-item {
            display: flex;
            gap: 12px;
            padding: 12px;
            margin-bottom: 10px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(212, 165, 116, 0.2);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-item:hover {
            background: rgba(255,255,255,0.12);
            border-color: var(--color-amber);
        }

        .file-item.active {
            background: rgba(212, 165, 116, 0.2);
            border-color: var(--color-ember);
        }

        .file-cover {
            width: 50px;
            height: 70px;
            border-radius: 4px;
            object-fit: cover;
            background: linear-gradient(135deg, var(--color-wood-light) 0%, var(--color-wood-dark) 100%);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: var(--color-cream);
            overflow: hidden;
        }

        .file-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            color: var(--color-cream);
            font-weight: 500;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-word;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .file-author {
            font-size: 11px;
            color: var(--color-amber);
            opacity: 0.8;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-size {
            font-size: 10px;
            color: var(--color-amber);
            opacity: 0.7;
        }

        .file-type {
            font-size: 8px;
            padding: 2px 6px;
            background: var(--color-ember);
            color: white;
            border-radius: 3px;
            font-weight: 600;
        }

        .file-progress {
            margin-top: 6px;
            font-size: 10px;
            color: var(--color-amber);
        }

        .progress-bar {
            height: 3px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--color-ember);
            border-radius: 2px;
            transition: width 0.3s;
        }

        .delete-file {
            background: none;
            border: none;
            color: var(--color-ember);
            font-size: 11px;
            cursor: pointer;
            margin-top: 8px;
            opacity: 0.7;
        }

        .delete-file:hover {
            opacity: 1;
            text-decoration: underline;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--color-bg);
        }

        /* Reader Header */
        .reader-header {
            padding: 12px 20px;
            background: var(--color-surface);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .book-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 200px;
        }

        .book-title {
            font-family: 'Literata', Georgia, serif;
            font-weight: 600;
            font-size: 16px;
            color: var(--color-text);
        }

        .book-author {
            font-size: 13px;
            color: var(--color-text-secondary);
        }

        .reader-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--color-bg);
            border-radius: 8px;
            border: 1px solid var(--color-border);
        }

        .control-label {
            font-size: 11px;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn {
            padding: 8px 16px;
            background: var(--color-accent);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #3D6B1E;
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: var(--color-accent);
            color: white;
            border-color: var(--color-accent);
        }

        .btn-icon:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .page-info {
            font-size: 13px;
            color: var(--color-text-secondary);
            min-width: 80px;
            text-align: center;
        }

        /* Reading Area */
        .reading-area {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Reader Panel - Paginated View */
        .reader-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--color-surface);
            position: relative;
            overflow: hidden;
        }

        .page-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            overflow: hidden;
            position: relative;
        }

        .page-view {
            width: 100%;
            max-width: 800px;
            height: 100%;
            background: var(--color-surface);
            box-shadow: 0 2px 20px rgba(0,0,0,0.08);
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .page-content {
            flex: 1;
            padding: var(--page-margin);
            overflow: hidden;
            font-family: 'Literata', Georgia, serif;
            font-size: var(--font-size);
            line-height: var(--line-height);
            color: var(--color-text);
            text-align: justify;
            hyphens: auto;
            -webkit-hyphens: auto;
        }

        /* CSS columns-based pagination for smooth text flow */
        .page-content-wrapper {
            column-width: 100vw;
            column-gap: 80px;
            column-fill: auto;
            height: 100%;
        }

        .page-content.two-columns .page-content-wrapper {
            column-count: 2;
            column-width: auto;
        }

        /* CSS columns-based page flow for smooth text pagination */
        .page-flow-container {
            transition: transform 0.3s ease;
        }

        .page-flow-container p {
            margin: 0 0 1em 0;
            orphans: 2;
            widows: 2;
        }

        .page-flow-container h1,
        .page-flow-container h2,
        .page-flow-container h3 {
            break-after: avoid;
            page-break-after: avoid;
        }

        .page-flow-container img {
            max-width: 100%;
            height: auto;
            break-inside: avoid;
            page-break-inside: avoid;
        }

        .page-flow-container .chapter {
            break-before: column;
        }

        .page-flow-container .chapter:first-child {
            break-before: auto;
        }

        .page-content h1, .page-content h2, .page-content h3 {
            font-family: 'Literata', Georgia, serif;
            color: var(--color-text);
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            line-height: 1.3;
            column-span: all;
        }

        .page-content h1 {
            font-size: 1.8em;
            text-align: center;
            margin-top: 2em;
            margin-bottom: 1em;
        }

        .page-content h2 {
            font-size: 1.4em;
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 0.3em;
        }

        .page-content h3 {
            font-size: 1.2em;
        }

        .page-content p {
            margin: 0 0 1em 0;
            text-indent: 1.5em;
        }

        .page-content p:first-of-type,
        .page-content h1 + p,
        .page-content h2 + p,
        .page-content h3 + p {
            text-indent: 0;
        }

        .page-content p:first-of-type::first-letter {
            font-size: 3em;
            float: left;
            line-height: 1;
            margin-right: 0.1em;
            font-weight: 600;
        }

        .page-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 1em auto;
            border-radius: 4px;
        }

        .page-content blockquote {
            margin: 1em 2em;
            padding-left: 1em;
            border-left: 3px solid var(--color-accent);
            font-style: italic;
            color: var(--color-text-secondary);
        }

        /* Page Navigation Zones */
        .nav-zone {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 20%;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .nav-zone:hover {
            opacity: 1;
        }

        .nav-zone-left {
            left: 0;
            background: linear-gradient(to right, rgba(0,0,0,0.03), transparent);
        }

        .nav-zone-right {
            right: 0;
            background: linear-gradient(to left, rgba(0,0,0,0.03), transparent);
        }

        .nav-zone-icon {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: var(--color-text-secondary);
        }

        /* Page Footer */
        .page-footer {
            padding: 12px var(--page-margin);
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        /* Notes Panel */
        .notes-panel {
            width: 350px;
            background: linear-gradient(180deg, #4A3728 0%, #3A2A1F 100%);
            border-left: 1px solid rgba(212, 165, 116, 0.3);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .notes-panel.collapsed {
            width: 50px;
        }

        .notes-header {
            padding: 16px 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(212, 165, 116, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .notes-title {
            font-family: 'Literata', Georgia, serif;
            font-size: 16px;
            font-weight: 600;
            color: var(--color-cream);
        }

        .toggle-notes {
            background: none;
            border: none;
            color: var(--color-amber);
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
        }

        .notes-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .note-item {
            padding: 14px;
            background: rgba(253, 248, 240, 0.95);
            border-radius: 8px;
            margin-bottom: 12px;
            position: relative;
        }

        .note-page {
            font-size: 10px;
            color: var(--color-ember);
            background: rgba(198, 93, 59, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            display: inline-block;
            margin-bottom: 8px;
        }

        .note-text {
            font-size: 14px;
            color: var(--color-wood-dark);
            line-height: 1.5;
        }

        .note-time {
            font-size: 11px;
            color: var(--color-wood-medium);
            margin-top: 8px;
        }

        .note-drawing {
            width: 100%;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .delete-note {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #8B3A3A;
            font-size: 18px;
            cursor: pointer;
            opacity: 0.6;
        }

        .delete-note:hover {
            opacity: 1;
        }

        .note-input-area {
            padding: 16px;
            background: rgba(0,0,0,0.15);
            border-top: 1px solid rgba(212, 165, 116, 0.2);
        }

        .input-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            color: var(--color-cream);
            border: 1px solid rgba(212, 165, 116, 0.3);
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn.active {
            background: var(--color-ember);
            border-color: var(--color-ember);
        }

        .input-content {
            display: none;
        }

        .input-content.active {
            display: block;
        }

        .note-textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(212, 165, 116, 0.3);
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            resize: none;
            min-height: 80px;
            background: rgba(253, 248, 240, 0.95);
            color: var(--color-wood-dark);
        }

        .note-textarea:focus {
            outline: none;
            border-color: var(--color-ember);
        }

        .canvas-toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .color-input {
            width: 36px;
            height: 32px;
            border: 1px solid rgba(212, 165, 116, 0.4);
            border-radius: 4px;
            cursor: pointer;
            padding: 2px;
        }

        .size-input {
            width: 60px;
            padding: 6px 8px;
            border: 1px solid rgba(212, 165, 116, 0.3);
            border-radius: 4px;
            font-size: 12px;
            background: var(--color-parchment);
        }

        #drawingCanvas {
            width: 100%;
            height: 120px;
            border: 1px solid rgba(212, 165, 116, 0.3);
            border-radius: 8px;
            background: rgba(253, 248, 240, 0.95);
            cursor: crosshair;
            touch-action: none;
        }

        .add-note-btn {
            width: 100%;
            padding: 12px;
            margin-top: 12px;
            background: var(--color-accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .add-note-btn:hover {
            background: #3D6B1E;
        }

        /* Empty States */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 40px;
            text-align: center;
        }

        .empty-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.6;
        }

        .empty-text {
            font-family: 'Literata', Georgia, serif;
            font-size: 18px;
            color: var(--color-text-secondary);
            max-width: 300px;
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100%;
            background: var(--color-surface);
            box-shadow: -4px 0 20px rgba(0,0,0,0.1);
            z-index: 100;
            transition: right 0.3s;
            display: flex;
            flex-direction: column;
        }

        .settings-panel.open {
            right: 0;
        }

        .settings-header {
            padding: 20px;
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .settings-title {
            font-family: 'Literata', Georgia, serif;
            font-size: 20px;
            font-weight: 600;
        }

        .close-settings {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--color-text-secondary);
        }

        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .setting-group {
            margin-bottom: 24px;
        }

        .setting-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: 8px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .setting-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: var(--color-border);
            border-radius: 3px;
            outline: none;
        }

        .setting-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--color-accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-value {
            min-width: 50px;
            font-size: 14px;
            color: var(--color-text-secondary);
        }

        .setting-buttons {
            display: flex;
            gap: 8px;
        }

        .setting-btn {
            flex: 1;
            padding: 10px;
            background: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .setting-btn.active {
            background: var(--color-accent);
            color: white;
            border-color: var(--color-accent);
        }

        /* Export Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 200;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--color-surface);
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--color-border);
        }

        .modal-title {
            font-family: 'Literata', Georgia, serif;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .modal-subtitle {
            font-size: 14px;
            color: var(--color-text-secondary);
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--color-accent);
        }

        .form-select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: var(--color-surface);
            cursor: pointer;
        }

        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .form-checkbox input {
            width: 18px;
            height: 18px;
            accent-color: var(--color-accent);
        }

        .quality-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .quality-option {
            padding: 16px 12px;
            border: 2px solid var(--color-border);
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quality-option:hover {
            border-color: var(--color-accent);
        }

        .quality-option.selected {
            border-color: var(--color-accent);
            background: var(--color-accent-light);
        }

        .quality-name {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .quality-desc {
            font-size: 11px;
            color: var(--color-text-secondary);
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--color-border);
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .btn-secondary {
            padding: 10px 20px;
            background: var(--color-bg);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        }

        .btn-primary {
            padding: 10px 24px;
            background: var(--color-accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 14px 24px;
            background: var(--color-wood-dark);
            color: white;
            border-radius: 10px;
            font-size: 14px;
            z-index: 300;
            animation: slideIn 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: 350px;
        }

        .toast.success { background: var(--color-accent); }
        .toast.error { background: #8B3A3A; }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Loading */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            gap: 16px;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--color-border);
            border-top-color: var(--color-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar { width: 260px; }
            .notes-panel { width: 300px; }
        }

        @media (max-width: 768px) {
            .app-container { flex-direction: column; }
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 180px;
                border-right: none;
                border-bottom: 2px solid var(--color-wood-light);
            }
            .notes-panel {
                position: fixed;
                top: 0;
                right: -100%;
                width: 100%;
                height: 100%;
                z-index: 50;
                transition: right 0.3s;
            }
            .notes-panel.open { right: 0; }
            .nav-zone { width: 15%; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="app-title">üìö ReadNote Plus</div>
                <div class="app-subtitle">E-Reader & Note-Taking</div>
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    + Add Book
                </button>
                <input type="file" id="fileInput" accept=".pdf,.epub,.txt" multiple>
            </div>
            <div class="sidebar-content">
                <div class="section-title">Library</div>
                <div id="fileList"></div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Reader Header -->
            <header class="reader-header" id="readerHeader" style="display: none;">
                <div class="book-info">
                    <div>
                        <div class="book-title" id="bookTitle">Book Title</div>
                        <div class="book-author" id="bookAuthor">Author</div>
                    </div>
                </div>
                <div class="reader-controls">
                    <div class="control-group" id="pageControls">
                        <button class="btn-icon" onclick="prevPage()" title="Previous">‚Äπ</button>
                        <span class="page-info" id="pageInfo">1 / 1</span>
                        <button class="btn-icon" onclick="nextPage()" title="Next">‚Ä∫</button>
                    </div>
                    <div class="control-group" id="chapterControls" style="display: none;">
                        <select id="chapterSelect" onchange="goToChapter(this.value)"></select>
                    </div>
                    <button class="btn-icon" onclick="toggleSettings()" title="Settings">‚öô</button>
                    <button class="btn" onclick="openExportModal()">Export EPUB</button>
                </div>
            </header>

            <!-- Reading Area -->
            <div class="reading-area">
                <div class="reader-panel" id="readerPanel">
                    <div class="page-container" id="pageContainer">
                        <div class="empty-state" id="emptyState">
                            <div class="empty-icon">üìñ</div>
                            <div class="empty-text">Select a book from your library or add a new one to start reading</div>
                        </div>
                        <div class="page-view" id="pageView" style="display: none;">
                            <div class="page-content" id="pageContent"></div>
                            <div class="page-footer">
                                <span id="chapterName"></span>
                                <span id="pageNumber"></span>
                            </div>
                        </div>
                    </div>
                    <!-- Navigation Zones -->
                    <div class="nav-zone nav-zone-left" onclick="prevPage()">
                        <div class="nav-zone-icon">‚Äπ</div>
                    </div>
                    <div class="nav-zone nav-zone-right" onclick="nextPage()">
                        <div class="nav-zone-icon">‚Ä∫</div>
                    </div>
                </div>

                <!-- Notes Panel -->
                <aside class="notes-panel" id="notesPanel">
                    <div class="notes-header">
                        <span class="notes-title">üìù Notes</span>
                        <button class="toggle-notes" onclick="toggleNotes()">‚úï</button>
                    </div>
                    <div class="notes-content" id="notesContent">
                        <div class="empty-state">
                            <div class="empty-icon">‚úçÔ∏è</div>
                            <div class="empty-text">Your notes will appear here</div>
                        </div>
                    </div>
                    <div class="note-input-area">
                        <div class="input-tabs">
                            <button class="tab-btn active" onclick="switchNoteTab('text')">Write</button>
                            <button class="tab-btn" onclick="switchNoteTab('draw')">Sketch</button>
                        </div>
                        <div id="textInput" class="input-content active">
                            <textarea class="note-textarea" id="noteInput" placeholder="Write your thoughts..."></textarea>
                        </div>
                        <div id="drawInput" class="input-content">
                            <div class="canvas-toolbar">
                                <input type="color" id="brushColor" class="color-input" value="#1A1A1A">
                                <input type="number" id="brushSize" class="size-input" value="2" min="1" max="20">
                                <button class="btn" onclick="clearCanvas()" style="padding: 6px 12px; font-size: 12px;">Clear</button>
                            </div>
                            <canvas id="drawingCanvas"></canvas>
                        </div>
                        <button class="add-note-btn" onclick="addNote()">Save Note</button>
                    </div>
                </aside>
            </div>
        </main>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <span class="settings-title">Reading Settings</span>
            <button class="close-settings" onclick="toggleSettings()">‚úï</button>
        </div>
        <div class="settings-content">
            <div class="setting-group">
                <div class="setting-label">Font Size</div>
                <div class="setting-row">
                    <input type="range" class="setting-slider" id="fontSizeSlider" min="14" max="28" value="18" onchange="updateFontSize(this.value)">
                    <span class="setting-value" id="fontSizeValue">18px</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Line Height</div>
                <div class="setting-row">
                    <input type="range" class="setting-slider" id="lineHeightSlider" min="1.4" max="2.4" step="0.1" value="1.8" onchange="updateLineHeight(this.value)">
                    <span class="setting-value" id="lineHeightValue">1.8</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Page Margins</div>
                <div class="setting-row">
                    <input type="range" class="setting-slider" id="marginSlider" min="20" max="80" value="40" onchange="updateMargins(this.value)">
                    <span class="setting-value" id="marginValue">40px</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Layout</div>
                <div class="setting-buttons">
                    <button class="setting-btn active" onclick="setLayout('single')">Single Column</button>
                    <button class="setting-btn" onclick="setLayout('two')">Two Columns</button>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Theme</div>
                <div class="setting-buttons">
                    <button class="setting-btn active" onclick="setTheme('light')">Light</button>
                    <button class="setting-btn" onclick="setTheme('sepia')">Sepia</button>
                    <button class="setting-btn" onclick="setTheme('dark')">Dark</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Export to EPUB</div>
                <div class="modal-subtitle">Create a high-quality ebook for your e-reader</div>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Book Title</label>
                    <input type="text" class="form-input" id="exportTitle" placeholder="Enter book title">
                </div>
                <div class="form-group">
                    <label class="form-label">Author</label>
                    <input type="text" class="form-input" id="exportAuthor" placeholder="Enter author name">
                </div>
                <div class="form-group">
                    <label class="form-label">Language</label>
                    <select class="form-select" id="exportLanguage">
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="it">Italian</option>
                        <option value="pt">Portuguese</option>
                        <option value="ja">Japanese</option>
                        <option value="zh">Chinese</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Export Quality</label>
                    <div class="quality-options">
                        <div class="quality-option" onclick="selectQuality('standard')">
                            <div class="quality-name">Standard</div>
                            <div class="quality-desc">Good compatibility</div>
                        </div>
                        <div class="quality-option selected" onclick="selectQuality('high')">
                            <div class="quality-name">High</div>
                            <div class="quality-desc">Best for e-readers</div>
                        </div>
                        <div class="quality-option" onclick="selectQuality('print')">
                            <div class="quality-name">Print</div>
                            <div class="quality-desc">PDF-like layout</div>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="includeNotes" checked>
                        <span>Include my notes in export</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="includeToc" checked>
                        <span>Generate table of contents</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="preserveFormatting" checked>
                        <span>Preserve original formatting</span>
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeExportModal()">Cancel</button>
                <button class="btn-primary" onclick="exportEpub()">Export EPUB</button>
            </div>
        </div>
    </div>

    <script>
        // Configure PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // State
        const state = {
            files: [],
            currentFileIndex: -1,
            notes: {},
            bookmarks: {},
            readingProgress: {},
            currentPage: 1,
            totalPages: 1,
            pdfDoc: null,
            chapters: [],
            currentChapter: 0,
            pages: [],
            pageWrapper: null,
            columnWidth: 0,
            settings: {
                fontSize: 18,
                lineHeight: 1.8,
                margin: 40,
                layout: 'single',
                theme: 'light'
            },
            exportQuality: 'high'
        };

        // Initialize
        function init() {
            loadState();
            renderFileList();
            setupKeyboardNav();
            setupTouchNav();
            initCanvas();
        }

        function loadState() {
            try {
                const saved = localStorage.getItem('readNotePlusData');
                if (saved) {
                    const data = JSON.parse(saved);
                    state.notes = data.notes || {};
                    state.bookmarks = data.bookmarks || {};
                    state.readingProgress = data.readingProgress || {};
                    state.settings = { ...state.settings, ...data.settings };
                    applySettings();
                }
            } catch (e) {
                console.error('Failed to load state:', e);
            }
        }

        function saveState() {
            try {
                localStorage.setItem('readNotePlusData', JSON.stringify({
                    notes: state.notes,
                    bookmarks: state.bookmarks,
                    readingProgress: state.readingProgress,
                    settings: state.settings
                }));
            } catch (e) {
                console.error('Failed to save state:', e);
            }
        }

        // File handling
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            for (const file of e.target.files) {
                await loadFile(file);
            }
            e.target.value = '';
        });

        async function loadFile(file) {
            const fileData = {
                name: file.name,
                type: file.name.split('.').pop().toUpperCase(),
                size: file.size,
                content: null,
                metadata: { title: file.name.replace(/\.[^/.]+$/, ''), author: 'Unknown' }
            };

            showToast('Loading ' + file.name + '...');

            try {
                if (file.name.endsWith('.txt')) {
                    fileData.content = await readAsText(file);
                    fileData.chapters = parseTextChapters(fileData.content);
                } else if (file.name.endsWith('.pdf')) {
                    fileData.rawData = await readAsArrayBuffer(file);
                    // Extract text from PDF for EPUB export
                    showToast('Extracting text from PDF (this may take a moment)...');
                    const pdfExtract = await extractPdfText(fileData.rawData);
                    fileData.content = pdfExtract.content;
                    fileData.chapters = pdfExtract.chapters;
                    fileData.metadata.title = file.name.replace(/\.pdf$/i, '');
                    showToast(`Extracted ${pdfExtract.chapters.length} sections from PDF`, 'success');
                } else if (file.name.endsWith('.epub')) {
                    fileData.rawData = await readAsArrayBuffer(file);
                    const epub = await parseEpub(fileData.rawData);
                    fileData.content = epub.content;
                    fileData.chapters = epub.chapters;
                    fileData.metadata = epub.metadata;
                    fileData.styles = epub.styles;
                    fileData.images = epub.images;
                }

                state.files.push(fileData);
                if (!state.notes[file.name]) state.notes[file.name] = [];

                renderFileList();
                selectFile(state.files.length - 1);
                showToast('Loaded: ' + file.name, 'success');
            } catch (err) {
                console.error('Error loading file:', err);
                showToast('Failed to load: ' + err.message, 'error');
            }
        }

        function readAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function readAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // Extract text from PDF for EPUB export
        async function extractPdfText(arrayBuffer) {
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const numPages = pdf.numPages;
            const chapters = [];
            let fullContent = '';
            let currentChapter = { title: 'Chapter 1', content: '', pageStart: 1 };
            let chapterNum = 1;

            for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const textContent = await page.getTextContent();

                let pageText = '';
                let lastY = null;
                let lastFontSize = 0;

                // Extract text with layout awareness
                for (const item of textContent.items) {
                    if (item.str.trim() === '') continue;

                    // Add newlines for significant Y position changes (new lines)
                    if (lastY !== null && Math.abs(item.transform[5] - lastY) > 8) {
                        pageText += '\n';
                    }

                    // Detect potential chapter headings (larger font at start of section)
                    const fontSize = Math.abs(item.transform[0]);
                    if (fontSize > lastFontSize * 1.3 && fontSize > 14 &&
                        pageText.endsWith('\n') && item.str.trim().length > 0 &&
                        item.str.trim().length < 100) {
                        // Potential chapter heading detected
                        const headingText = item.str.trim();

                        // Check if it looks like a chapter heading
                        if (/^(chapter|part|section|\d+[.\s]|[ivxlcdm]+[.\s])/i.test(headingText) ||
                            (headingText.length < 60 && !headingText.includes('.'))) {

                            // Save current chapter if it has content
                            if (currentChapter.content.trim().length > 100) {
                                chapters.push({
                                    title: currentChapter.title,
                                    content: formatPdfContent(currentChapter.content)
                                });
                            }

                            chapterNum++;
                            currentChapter = {
                                title: headingText || `Chapter ${chapterNum}`,
                                content: '',
                                pageStart: pageNum
                            };
                        }
                    }

                    pageText += item.str;
                    lastY = item.transform[5];
                    lastFontSize = fontSize;
                }

                currentChapter.content += pageText + '\n\n';
                fullContent += pageText + '\n\n';

                // Add page marker for reference
                if (pageNum < numPages) {
                    currentChapter.content += `<!-- page ${pageNum} -->\n`;
                }
            }

            // Add final chapter
            if (currentChapter.content.trim().length > 0) {
                chapters.push({
                    title: currentChapter.title,
                    content: formatPdfContent(currentChapter.content)
                });
            }

            // If no chapters detected, split by page groups
            if (chapters.length <= 1 && numPages > 10) {
                const pagesPerChapter = Math.ceil(numPages / Math.min(10, Math.ceil(numPages / 20)));
                const rechaptered = [];
                let chapterContent = '';
                let chNum = 1;

                for (let i = 0; i < chapters.length; i++) {
                    const ch = chapters[i];
                    chapterContent += ch.content;
                }

                // Split by approximate page markers
                const pageMarkers = chapterContent.split(/<!-- page \d+ -->/);
                let tempContent = '';

                for (let i = 0; i < pageMarkers.length; i++) {
                    tempContent += pageMarkers[i];

                    if ((i + 1) % pagesPerChapter === 0 || i === pageMarkers.length - 1) {
                        if (tempContent.trim()) {
                            rechaptered.push({
                                title: `Section ${chNum}`,
                                content: formatPdfContent(tempContent)
                            });
                            chNum++;
                            tempContent = '';
                        }
                    }
                }

                if (rechaptered.length > 1) {
                    return { content: fullContent, chapters: rechaptered };
                }
            }

            return { content: fullContent, chapters };
        }

        function formatPdfContent(text) {
            // Clean up PDF text extraction artifacts
            return text
                .replace(/<!-- page \d+ -->/g, '') // Remove page markers
                .replace(/\n{3,}/g, '\n\n')        // Normalize multiple newlines
                .replace(/([a-z])-\n([a-z])/gi, '$1$2') // Fix hyphenated words
                .replace(/([.!?])\n([A-Z])/g, '$1\n\n$2') // Paragraph breaks after sentences
                .split('\n\n')
                .filter(p => p.trim().length > 0)
                .map(p => `<p>${escapeHtml(p.trim()).replace(/\n/g, ' ')}</p>`)
                .join('\n');
        }

        // EPUB Parser - Enhanced
        async function parseEpub(arrayBuffer) {
            const zip = await JSZip.loadAsync(arrayBuffer);

            // Find container
            const containerXml = await zip.file('META-INF/container.xml')?.async('text');
            if (!containerXml) throw new Error('Invalid EPUB');

            const parser = new DOMParser();
            const containerDoc = parser.parseFromString(containerXml, 'text/xml');
            const opfPath = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
            if (!opfPath) throw new Error('Invalid EPUB structure');

            const opfDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);

            // Parse OPF
            const opfContent = await zip.file(opfPath)?.async('text');
            const opfDoc = parser.parseFromString(opfContent, 'text/xml');

            // Metadata
            const metadata = {
                title: opfDoc.querySelector('metadata title, dc\\:title')?.textContent || 'Untitled',
                author: opfDoc.querySelector('metadata creator, dc\\:creator')?.textContent || 'Unknown',
                publisher: opfDoc.querySelector('metadata publisher, dc\\:publisher')?.textContent || '',
                language: opfDoc.querySelector('metadata language, dc\\:language')?.textContent || 'en',
                description: opfDoc.querySelector('metadata description, dc\\:description')?.textContent || '',
                date: opfDoc.querySelector('metadata date, dc\\:date')?.textContent || '',
                cover: null
            };

            // Build manifest map
            const manifestMap = {};
            opfDoc.querySelectorAll('manifest item').forEach(item => {
                manifestMap[item.getAttribute('id')] = {
                    href: item.getAttribute('href'),
                    mediaType: item.getAttribute('media-type')
                };
            });

            // Get spine order
            const spine = Array.from(opfDoc.querySelectorAll('spine itemref'));

            // Extract styles
            const styles = [];
            for (const [id, item] of Object.entries(manifestMap)) {
                if (item.mediaType === 'text/css') {
                    const cssContent = await zip.file(opfDir + item.href)?.async('text');
                    if (cssContent) styles.push(cssContent);
                }
            }

            // Extract images and find cover
            const images = {};

            // Find cover image - multiple methods
            // Method 1: Look for meta cover element
            const coverMeta = opfDoc.querySelector('metadata meta[name="cover"]');
            const coverId = coverMeta?.getAttribute('content');

            // Method 2: Look for item with cover-image property
            const coverItem = opfDoc.querySelector('manifest item[properties*="cover-image"]');

            // Method 3: Look for item with id containing 'cover'
            const coverById = Object.entries(manifestMap).find(([id, item]) =>
                id.toLowerCase().includes('cover') && item.mediaType?.startsWith('image/')
            );

            for (const [id, item] of Object.entries(manifestMap)) {
                if (item.mediaType?.startsWith('image/')) {
                    const imgData = await zip.file(opfDir + item.href)?.async('base64');
                    if (imgData) {
                        const dataUrl = `data:${item.mediaType};base64,${imgData}`;
                        images[item.href] = dataUrl;

                        // Check if this is the cover
                        if ((coverId && id === coverId) ||
                            (coverItem && item.href === coverItem.getAttribute('href')) ||
                            (coverById && id === coverById[0]) ||
                            (!metadata.cover && (
                                item.href.toLowerCase().includes('cover') ||
                                id.toLowerCase() === 'cover'
                            ))) {
                            metadata.cover = dataUrl;
                        }
                    }
                }
            }

            // Parse chapters
            const chapters = [];
            let fullContent = '';

            for (const itemref of spine) {
                const idref = itemref.getAttribute('idref');
                const item = manifestMap[idref];

                if (item && item.mediaType?.includes('html')) {
                    const chapterHtml = await zip.file(opfDir + item.href)?.async('text');
                    if (chapterHtml) {
                        const chapterDoc = parser.parseFromString(chapterHtml, 'text/html');
                        const body = chapterDoc.body;

                        if (body) {
                            // Fix image paths
                            body.querySelectorAll('img').forEach(img => {
                                const src = img.getAttribute('src');
                                if (src) {
                                    const cleanSrc = src.replace(/^\.\.\//, '').replace(/^\.\//, '');
                                    if (images[cleanSrc]) {
                                        img.setAttribute('src', images[cleanSrc]);
                                    }
                                }
                            });

                            // Get chapter title
                            const h1 = body.querySelector('h1, h2, h3');
                            const title = h1?.textContent?.trim() || `Chapter ${chapters.length + 1}`;

                            chapters.push({
                                title: title,
                                content: body.innerHTML,
                                id: `chapter-${chapters.length}`
                            });

                            fullContent += `<section id="chapter-${chapters.length - 1}" class="chapter">
                                ${body.innerHTML}
                            </section>`;
                        }
                    }
                }
            }

            return {
                content: fullContent,
                chapters: chapters,
                metadata: metadata,
                styles: styles.join('\n'),
                images: images
            };
        }

        // Text chapter detection
        function parseTextChapters(text) {
            const chapters = [];
            const lines = text.split('\n');
            let currentChapter = { title: 'Start', content: '', startLine: 0 };

            const chapterPatterns = [
                /^chapter\s+\d+/i,
                /^part\s+\d+/i,
                /^section\s+\d+/i,
                /^cap√≠tulo\s+\d+/i,
                /^\d+\.\s+/,
                /^[IVX]+\.\s+/
            ];

            lines.forEach((line, index) => {
                const trimmed = line.trim();
                const isChapterTitle = chapterPatterns.some(p => p.test(trimmed)) ||
                    (trimmed.length > 0 && trimmed.length < 60 && trimmed === trimmed.toUpperCase());

                if (isChapterTitle && currentChapter.content.trim()) {
                    chapters.push({ ...currentChapter });
                    currentChapter = { title: trimmed, content: '', startLine: index };
                } else {
                    currentChapter.content += line + '\n';
                }
            });

            if (currentChapter.content.trim()) {
                chapters.push(currentChapter);
            }

            return chapters.length > 0 ? chapters : [{ title: 'Content', content: text }];
        }

        // Render file list
        function renderFileList() {
            const container = document.getElementById('fileList');
            container.innerHTML = state.files.map((file, i) => {
                const progress = state.readingProgress[file.name] || 0;
                const cover = file.metadata?.cover;
                const title = file.metadata?.title || file.name.replace(/\.[^/.]+$/, '');
                const author = file.metadata?.author;
                const typeIcon = file.type === 'PDF' ? 'üìÑ' : file.type === 'EPUB' ? 'üìö' : 'üìù';

                return `
                    <div class="file-item ${state.currentFileIndex === i ? 'active' : ''}" onclick="selectFile(${i})">
                        <div class="file-cover">
                            ${cover
                                ? `<img src="${cover}" alt="Cover">`
                                : typeIcon
                            }
                        </div>
                        <div class="file-info">
                            <div class="file-name">${escapeHtml(title)}</div>
                            ${author && author !== 'Unknown' ? `<div class="file-author">${escapeHtml(author)}</div>` : ''}
                            <div class="file-meta">
                                <span class="file-size">${formatSize(file.size)}</span>
                                <span class="file-type">${file.type}</span>
                            </div>
                            ${progress > 0 ? `
                                <div class="file-progress">
                                    ${Math.round(progress)}% read
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${progress}%"></div>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Select and display file
        async function selectFile(index) {
            state.currentFileIndex = index;
            const file = state.files[index];

            document.getElementById('readerHeader').style.display = 'flex';
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('pageView').style.display = 'flex';

            document.getElementById('bookTitle').textContent = file.metadata?.title || file.name;
            document.getElementById('bookAuthor').textContent = file.metadata?.author || '';

            // Build chapter select
            if (file.chapters && file.chapters.length > 1) {
                document.getElementById('chapterControls').style.display = 'block';
                const select = document.getElementById('chapterSelect');
                select.innerHTML = file.chapters.map((ch, i) =>
                    `<option value="${i}">${escapeHtml(ch.title)}</option>`
                ).join('');
            } else {
                document.getElementById('chapterControls').style.display = 'none';
            }

            if (file.type === 'PDF') {
                await renderPdf(file.rawData);
            } else {
                await renderBook(file);
            }

            // Restore reading position
            const savedProgress = state.readingProgress[file.name];
            if (savedProgress) {
                const targetPage = Math.floor((savedProgress / 100) * state.totalPages);
                if (targetPage > 1) goToPage(targetPage);
            }

            renderNotes();
            renderFileList();
        }

        // PDF Rendering
        async function renderPdf(data) {
            state.pdfDoc = await pdfjsLib.getDocument({ data }).promise;
            state.totalPages = state.pdfDoc.numPages;
            state.currentPage = 1;
            await renderPdfPage(state.currentPage);
        }

        async function renderPdfPage(pageNum) {
            const page = await state.pdfDoc.getPage(pageNum);
            const container = document.getElementById('pageContent');

            const containerWidth = container.clientWidth - (state.settings.margin * 2);
            const viewport = page.getViewport({ scale: 1 });
            const scale = containerWidth / viewport.width;
            const scaledViewport = page.getViewport({ scale });

            const canvas = document.createElement('canvas');
            canvas.width = scaledViewport.width;
            canvas.height = scaledViewport.height;

            await page.render({
                canvasContext: canvas.getContext('2d'),
                viewport: scaledViewport
            }).promise;

            container.innerHTML = '';
            container.appendChild(canvas);

            updatePageInfo();
        }

        // Book rendering with pagination
        async function renderBook(file) {
            state.pdfDoc = null;

            // Prepare content
            let html = '';
            if (file.chapters) {
                html = file.chapters.map((ch, i) => `
                    <section id="chapter-${i}" class="chapter">
                        <h2>${escapeHtml(ch.title)}</h2>
                        ${ch.content.includes('<') ? ch.content : formatText(ch.content)}
                    </section>
                `).join('<div class="chapter-break"></div>');
            } else {
                html = file.content.includes('<') ? file.content : formatText(file.content);
            }

            // Calculate pages
            await paginateContent(html);
        }

        function formatText(text) {
            return text.split('\n\n')
                .map(p => p.trim())
                .filter(p => p)
                .map(p => `<p>${escapeHtml(p).replace(/\n/g, '<br>')}</p>`)
                .join('');
        }

        async function paginateContent(html) {
            const container = document.getElementById('pageContent');

            // Use CSS columns for proper text flow pagination
            // This allows text to flow naturally across pages without cutting content
            const pageWidth = container.clientWidth;
            const pageHeight = container.clientHeight;
            const margin = state.settings.margin;
            const contentWidth = pageWidth - (margin * 2);
            const contentHeight = pageHeight - (margin * 2);

            // Create wrapper with CSS columns
            const wrapper = document.createElement('div');
            wrapper.className = 'page-flow-container';
            wrapper.style.cssText = `
                height: ${contentHeight}px;
                column-width: ${contentWidth}px;
                column-gap: ${margin * 2}px;
                column-fill: auto;
                overflow: hidden;
            `;
            wrapper.innerHTML = html;

            container.innerHTML = '';
            container.appendChild(wrapper);

            // Wait for layout to complete
            await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

            // Calculate total pages based on scroll width
            const totalWidth = wrapper.scrollWidth;
            const columnWidth = contentWidth + (margin * 2);
            state.totalPages = Math.max(1, Math.ceil(totalWidth / columnWidth));
            state.currentPage = 1;
            state.columnWidth = columnWidth;

            // Store wrapper reference for page navigation
            state.pageWrapper = wrapper;

            displayPage(1);
        }

        function displayPage(pageNum) {
            const container = document.getElementById('pageContent');

            if (state.pdfDoc) {
                renderPdfPage(pageNum);
            } else if (state.pageWrapper) {
                // Use CSS transform for smooth page transitions
                const offset = (pageNum - 1) * state.columnWidth;
                state.pageWrapper.style.transform = `translateX(-${offset}px)`;
            }

            state.currentPage = pageNum;
            updatePageInfo();
            updateReadingProgress();
        }

        function updatePageInfo() {
            document.getElementById('pageInfo').textContent = `${state.currentPage} / ${state.totalPages}`;
            document.getElementById('pageNumber').textContent = `Page ${state.currentPage} of ${state.totalPages}`;

            // Update chapter name
            const file = state.files[state.currentFileIndex];
            if (file?.chapters) {
                // Find current chapter based on page
                const chapterIndex = Math.min(
                    Math.floor((state.currentPage / state.totalPages) * file.chapters.length),
                    file.chapters.length - 1
                );
                document.getElementById('chapterName').textContent = file.chapters[chapterIndex]?.title || '';
            }
        }

        function updateReadingProgress() {
            if (state.currentFileIndex >= 0) {
                const file = state.files[state.currentFileIndex];
                const progress = (state.currentPage / state.totalPages) * 100;
                state.readingProgress[file.name] = progress;
                saveState();
            }
        }

        // Navigation
        function prevPage() {
            if (state.currentPage > 1) {
                displayPage(state.currentPage - 1);
            }
        }

        function nextPage() {
            if (state.currentPage < state.totalPages) {
                displayPage(state.currentPage + 1);
            }
        }

        function goToPage(page) {
            if (page >= 1 && page <= state.totalPages) {
                displayPage(page);
            }
        }

        function goToChapter(index) {
            const file = state.files[state.currentFileIndex];
            if (file?.chapters) {
                const chaptersPerPage = state.totalPages / file.chapters.length;
                const targetPage = Math.floor(index * chaptersPerPage) + 1;
                goToPage(targetPage);
            }
        }

        // Keyboard navigation
        function setupKeyboardNav() {
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch(e.key) {
                    case 'ArrowLeft':
                    case 'PageUp':
                        e.preventDefault();
                        prevPage();
                        break;
                    case 'ArrowRight':
                    case 'PageDown':
                    case ' ':
                        e.preventDefault();
                        nextPage();
                        break;
                    case 'Home':
                        e.preventDefault();
                        goToPage(1);
                        break;
                    case 'End':
                        e.preventDefault();
                        goToPage(state.totalPages);
                        break;
                }
            });
        }

        // Touch navigation
        function setupTouchNav() {
            let touchStartX = 0;
            const container = document.getElementById('pageContainer');

            container.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
            }, { passive: true });

            container.addEventListener('touchend', (e) => {
                const touchEndX = e.changedTouches[0].screenX;
                const diff = touchStartX - touchEndX;

                if (Math.abs(diff) > 50) {
                    if (diff > 0) nextPage();
                    else prevPage();
                }
            }, { passive: true });
        }

        // Settings
        function toggleSettings() {
            document.getElementById('settingsPanel').classList.toggle('open');
        }

        function updateFontSize(value) {
            state.settings.fontSize = parseInt(value);
            document.getElementById('fontSizeValue').textContent = value + 'px';
            document.documentElement.style.setProperty('--font-size', value + 'px');
            saveState();
            if (state.currentFileIndex >= 0) {
                const file = state.files[state.currentFileIndex];
                if (file.type !== 'PDF') renderBook(file);
            }
        }

        function updateLineHeight(value) {
            state.settings.lineHeight = parseFloat(value);
            document.getElementById('lineHeightValue').textContent = value;
            document.documentElement.style.setProperty('--line-height', value);
            saveState();
            if (state.currentFileIndex >= 0) {
                const file = state.files[state.currentFileIndex];
                if (file.type !== 'PDF') renderBook(file);
            }
        }

        function updateMargins(value) {
            state.settings.margin = parseInt(value);
            document.getElementById('marginValue').textContent = value + 'px';
            document.documentElement.style.setProperty('--page-margin', value + 'px');
            saveState();
            if (state.currentFileIndex >= 0) {
                const file = state.files[state.currentFileIndex];
                if (file.type !== 'PDF') renderBook(file);
            }
        }

        function setLayout(layout) {
            state.settings.layout = layout;
            document.querySelectorAll('.setting-group:nth-child(4) .setting-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase().includes(layout));
            });
            const content = document.getElementById('pageContent');
            content.classList.toggle('two-columns', layout === 'two');
            saveState();
        }

        function setTheme(theme) {
            state.settings.theme = theme;
            document.querySelectorAll('.setting-group:nth-child(5) .setting-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase() === theme);
            });

            const root = document.documentElement;
            switch(theme) {
                case 'sepia':
                    root.style.setProperty('--color-bg', '#F4ECD8');
                    root.style.setProperty('--color-surface', '#FDF8F0');
                    root.style.setProperty('--color-text', '#5C4B37');
                    break;
                case 'dark':
                    root.style.setProperty('--color-bg', '#1A1A1A');
                    root.style.setProperty('--color-surface', '#2D2D2D');
                    root.style.setProperty('--color-text', '#E0E0E0');
                    break;
                default:
                    root.style.setProperty('--color-bg', '#FAFAF8');
                    root.style.setProperty('--color-surface', '#FFFFFF');
                    root.style.setProperty('--color-text', '#1A1A1A');
            }
            saveState();
        }

        function applySettings() {
            document.getElementById('fontSizeSlider').value = state.settings.fontSize;
            document.getElementById('fontSizeValue').textContent = state.settings.fontSize + 'px';
            document.getElementById('lineHeightSlider').value = state.settings.lineHeight;
            document.getElementById('lineHeightValue').textContent = state.settings.lineHeight;
            document.getElementById('marginSlider').value = state.settings.margin;
            document.getElementById('marginValue').textContent = state.settings.margin + 'px';

            updateFontSize(state.settings.fontSize);
            updateLineHeight(state.settings.lineHeight);
            updateMargins(state.settings.margin);
            setLayout(state.settings.layout);
            setTheme(state.settings.theme);
        }

        // Notes
        function toggleNotes() {
            document.getElementById('notesPanel').classList.toggle('open');
        }

        function switchNoteTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.input-content').forEach(el => el.classList.remove('active'));

            if (tab === 'text') {
                document.querySelectorAll('.tab-btn')[0].classList.add('active');
                document.getElementById('textInput').classList.add('active');
            } else {
                document.querySelectorAll('.tab-btn')[1].classList.add('active');
                document.getElementById('drawInput').classList.add('active');
                setTimeout(initCanvas, 50);
            }
        }

        function addNote() {
            if (state.currentFileIndex < 0) {
                showToast('Please open a book first', 'error');
                return;
            }

            const file = state.files[state.currentFileIndex];
            const isDrawing = document.getElementById('drawInput').classList.contains('active');
            let noteData;

            if (isDrawing) {
                const canvas = document.getElementById('drawingCanvas');
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const hasContent = imageData.data.some((v, i) => i % 4 === 3 && v > 0);

                if (!hasContent) {
                    showToast('Please draw something first', 'error');
                    return;
                }

                noteData = { type: 'drawing', content: canvas.toDataURL() };
                clearCanvas();
            } else {
                const text = document.getElementById('noteInput').value.trim();
                if (!text) {
                    showToast('Please enter some text', 'error');
                    return;
                }
                noteData = { type: 'text', content: text };
                document.getElementById('noteInput').value = '';
            }

            if (!state.notes[file.name]) state.notes[file.name] = [];
            state.notes[file.name].push({
                id: Date.now(),
                data: noteData,
                page: state.currentPage,
                timestamp: new Date().toLocaleString()
            });

            renderNotes();
            saveState();
            showToast('Note saved', 'success');
        }

        function renderNotes() {
            const container = document.getElementById('notesContent');
            if (state.currentFileIndex < 0) return;

            const file = state.files[state.currentFileIndex];
            const notes = state.notes[file.name] || [];

            if (notes.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">‚úçÔ∏è</div>
                        <div class="empty-text">Your notes will appear here</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = notes.map(note => `
                <div class="note-item">
                    <button class="delete-note" onclick="deleteNote(${note.id})">√ó</button>
                    <span class="note-page">Page ${note.page}</span>
                    ${note.data.type === 'text'
                        ? `<div class="note-text">${escapeHtml(note.data.content)}</div>`
                        : `<img src="${note.data.content}" class="note-drawing" alt="Note">`
                    }
                    <div class="note-time">${note.timestamp}</div>
                </div>
            `).join('');
        }

        function deleteNote(id) {
            const file = state.files[state.currentFileIndex];
            state.notes[file.name] = state.notes[file.name].filter(n => n.id !== id);
            renderNotes();
            saveState();
        }

        // Canvas
        let canvas, ctx, isDrawing = false;

        function initCanvas() {
            canvas = document.getElementById('drawingCanvas');
            if (!canvas) return;

            ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            ctx.scale(devicePixelRatio, devicePixelRatio);

            canvas.onpointerdown = startDraw;
            canvas.onpointermove = draw;
            canvas.onpointerup = canvas.onpointerleave = stopDraw;
        }

        function startDraw(e) {
            isDrawing = true;
            ctx.beginPath();
            ctx.moveTo(e.offsetX, e.offsetY);
        }

        function draw(e) {
            if (!isDrawing) return;
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.strokeStyle = document.getElementById('brushColor').value;
            ctx.lineWidth = (parseInt(document.getElementById('brushSize').value) || 2) * (e.pressure || 0.5);
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(e.offsetX, e.offsetY);
        }

        function stopDraw() {
            isDrawing = false;
        }

        function clearCanvas() {
            if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Export Modal
        function openExportModal() {
            if (state.currentFileIndex < 0) {
                showToast('Please open a book first', 'error');
                return;
            }

            const file = state.files[state.currentFileIndex];
            document.getElementById('exportTitle').value = file.metadata?.title || file.name.replace(/\.[^/.]+$/, '');
            document.getElementById('exportAuthor').value = file.metadata?.author || '';
            document.getElementById('exportLanguage').value = file.metadata?.language || 'en';

            document.getElementById('exportModal').classList.add('active');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('active');
        }

        function selectQuality(quality) {
            state.exportQuality = quality;
            document.querySelectorAll('.quality-option').forEach(opt => {
                opt.classList.toggle('selected', opt.onclick.toString().includes(quality));
            });
        }

        // EPUB Export - Professional Quality
        async function exportEpub() {
            const file = state.files[state.currentFileIndex];
            const title = document.getElementById('exportTitle').value || 'Untitled';
            const author = document.getElementById('exportAuthor').value || 'Unknown';
            const language = document.getElementById('exportLanguage').value;
            const includeNotes = document.getElementById('includeNotes').checked;
            const includeToc = document.getElementById('includeToc').checked;
            const preserveFormatting = document.getElementById('preserveFormatting').checked;

            showToast('Creating EPUB...');

            try {
                const zip = new JSZip();
                const uuid = 'urn:uuid:' + crypto.randomUUID();
                const timestamp = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');

                // mimetype (uncompressed, first file)
                zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' });

                // META-INF/container.xml
                zip.file('META-INF/container.xml', `<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`);

                // Build chapters
                const chapters = file.chapters || [{ title: 'Content', content: file.content }];
                const notes = includeNotes ? (state.notes[file.name] || []) : [];

                // Get original cover if available
                const originalCover = file.metadata?.cover;
                let coverManifest = '';
                let coverMeta = '';

                if (originalCover) {
                    // Extract image type from data URL
                    const coverMatch = originalCover.match(/^data:image\/(jpeg|png|gif|webp);base64,(.+)$/);
                    if (coverMatch) {
                        const coverType = coverMatch[1] === 'jpeg' ? 'jpg' : coverMatch[1];
                        const coverData = coverMatch[2];
                        const coverMime = `image/${coverMatch[1]}`;

                        // Add cover image to EPUB
                        zip.file(`OEBPS/images/cover.${coverType}`, coverData, { base64: true });

                        coverManifest = `
    <item id="cover-image" href="images/cover.${coverType}" media-type="${coverMime}" properties="cover-image"/>
    <item id="cover" href="cover.xhtml" media-type="application/xhtml+xml"/>`;
                        coverMeta = `
    <meta name="cover" content="cover-image"/>`;

                        // Create cover page
                        zip.file('OEBPS/cover.xhtml', `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="${language}">
<head>
  <meta charset="UTF-8"/>
  <title>Cover</title>
  <style>
    body { margin: 0; padding: 0; text-align: center; }
    img { max-width: 100%; max-height: 100vh; }
  </style>
</head>
<body>
  <img src="images/cover.${coverType}" alt="Cover"/>
</body>
</html>`);
                    }
                }

                // Generate manifest and spine
                let manifestItems = `
    <item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>
    <item id="css" href="styles.css" media-type="text/css"/>${coverManifest}`;

                let spineItems = originalCover ? `
    <itemref idref="cover"/>` : '';

                chapters.forEach((ch, i) => {
                    manifestItems += `
    <item id="chapter${i}" href="chapter${i}.xhtml" media-type="application/xhtml+xml"/>`;
                    spineItems += `
    <itemref idref="chapter${i}"/>`;
                });

                if (notes.length > 0) {
                    manifestItems += `
    <item id="notes" href="notes.xhtml" media-type="application/xhtml+xml"/>`;
                    spineItems += `
    <itemref idref="notes"/>`;
                }

                // OEBPS/content.opf
                zip.file('OEBPS/content.opf', `<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" version="3.0" unique-identifier="uid">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
    <dc:identifier id="uid">${uuid}</dc:identifier>
    <dc:title>${escapeXml(title)}</dc:title>
    <dc:creator>${escapeXml(author)}</dc:creator>
    <dc:language>${language}</dc:language>
    <dc:date>${timestamp}</dc:date>
    <meta property="dcterms:modified">${timestamp}</meta>
    <meta name="generator" content="ReadNote Plus"/>
  </metadata>
  <manifest>${manifestItems}
  </manifest>
  <spine>${spineItems}
  </spine>
</package>`);

                // Navigation document
                let navContent = chapters.map((ch, i) =>
                    `      <li><a href="chapter${i}.xhtml">${escapeXml(ch.title)}</a></li>`
                ).join('\n');

                if (notes.length > 0) {
                    navContent += `\n      <li><a href="notes.xhtml">Notes</a></li>`;
                }

                zip.file('OEBPS/nav.xhtml', `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="${language}">
<head>
  <meta charset="UTF-8"/>
  <title>Table of Contents</title>
  <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
  <nav epub:type="toc" id="toc">
    <h1>Table of Contents</h1>
    <ol>
${navContent}
    </ol>
  </nav>
</body>
</html>`);

                // Styles optimized for e-readers
                const cssQuality = {
                    standard: `
body { margin: 1em; font-family: serif; line-height: 1.5; }
h1, h2, h3 { margin: 1em 0 0.5em; }
p { margin: 0 0 0.8em; text-indent: 1.5em; text-align: justify; }
p:first-of-type { text-indent: 0; }
img { max-width: 100%; height: auto; }`,
                    high: `
@page { margin: 2cm; }
body {
  font-family: "Literata", "Georgia", "Times New Roman", serif;
  font-size: 1em;
  line-height: 1.8;
  margin: 0;
  padding: 1.5em;
  text-rendering: optimizeLegibility;
  -webkit-hyphens: auto;
  hyphens: auto;
  orphans: 2;
  widows: 2;
}
h1 {
  font-size: 2em;
  text-align: center;
  margin: 2em 0 1em;
  page-break-after: avoid;
  line-height: 1.2;
}
h2 {
  font-size: 1.5em;
  margin: 1.5em 0 0.5em;
  page-break-after: avoid;
  border-bottom: 1px solid #ccc;
  padding-bottom: 0.3em;
}
h3 {
  font-size: 1.2em;
  margin: 1.2em 0 0.4em;
  page-break-after: avoid;
}
p {
  margin: 0 0 1em;
  text-indent: 1.5em;
  text-align: justify;
}
p:first-of-type,
h1 + p, h2 + p, h3 + p {
  text-indent: 0;
}
p:first-of-type::first-letter {
  font-size: 3em;
  float: left;
  line-height: 1;
  margin-right: 0.1em;
  font-weight: bold;
}
blockquote {
  margin: 1em 2em;
  padding-left: 1em;
  border-left: 3px solid #666;
  font-style: italic;
}
img {
  max-width: 100%;
  height: auto;
  display: block;
  margin: 1em auto;
  page-break-inside: avoid;
}
.chapter { page-break-before: always; }
.note {
  background: #f5f5f5;
  padding: 1em;
  margin: 1em 0;
  border-left: 4px solid #2D5016;
  border-radius: 4px;
}
.note-text { font-style: italic; }
.note-meta { font-size: 0.85em; color: #666; margin-top: 0.5em; }
.note-drawing { max-width: 100%; border: 1px solid #ddd; border-radius: 4px; }`,
                    print: `
@page {
  margin: 2.5cm;
  @bottom-center { content: counter(page); }
}
body {
  font-family: "Literata", "Palatino", serif;
  font-size: 11pt;
  line-height: 1.6;
  text-align: justify;
  -webkit-hyphens: auto;
  hyphens: auto;
}
h1 {
  font-size: 24pt;
  text-align: center;
  margin: 3em 0 2em;
  page-break-before: always;
}
h2 { font-size: 16pt; margin: 2em 0 1em; }
p { margin: 0 0 0.5em; text-indent: 2em; }
p:first-of-type { text-indent: 0; }
img { max-width: 100%; page-break-inside: avoid; }`
                };

                zip.file('OEBPS/styles.css', cssQuality[state.exportQuality] || cssQuality.high);

                // Chapter files
                for (let i = 0; i < chapters.length; i++) {
                    const ch = chapters[i];
                    let chapterContent = ch.content;

                    // Convert plain text to HTML if needed
                    if (!chapterContent.includes('<')) {
                        chapterContent = chapterContent.split('\n\n')
                            .map(p => p.trim())
                            .filter(p => p)
                            .map(p => `<p>${escapeXml(p).replace(/\n/g, '<br/>')}</p>`)
                            .join('\n');
                    }

                    zip.file(`OEBPS/chapter${i}.xhtml`, `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="${language}">
<head>
  <meta charset="UTF-8"/>
  <title>${escapeXml(ch.title)}</title>
  <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
  <section class="chapter" epub:type="chapter">
    <h1>${escapeXml(ch.title)}</h1>
    ${chapterContent}
  </section>
</body>
</html>`);
                }

                // Notes file
                if (notes.length > 0) {
                    let notesHtml = notes.map((note, i) => {
                        if (note.data.type === 'text') {
                            return `<div class="note">
      <p class="note-text">"${escapeXml(note.data.content)}"</p>
      <p class="note-meta">Page ${note.page} ‚Ä¢ ${note.timestamp}</p>
    </div>`;
                        } else {
                            // Save image and reference it
                            const imgName = `note_${i}.png`;
                            const imgData = note.data.content.split(',')[1];
                            zip.file(`OEBPS/images/${imgName}`, imgData, { base64: true });
                            return `<div class="note">
      <img class="note-drawing" src="images/${imgName}" alt="Note sketch"/>
      <p class="note-meta">Page ${note.page} ‚Ä¢ ${note.timestamp}</p>
    </div>`;
                        }
                    }).join('\n');

                    zip.file('OEBPS/notes.xhtml', `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="${language}">
<head>
  <meta charset="UTF-8"/>
  <title>Notes</title>
  <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
  <section class="chapter">
    <h1>Reading Notes</h1>
    <p><em>Notes for: ${escapeXml(title)}</em></p>
    ${notesHtml}
  </section>
</body>
</html>`);
                }

                // Generate EPUB
                const blob = await zip.generateAsync({
                    type: 'blob',
                    mimeType: 'application/epub+zip',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 9 }
                });

                // Download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${title}.epub`;
                a.click();

                // Add exported EPUB to library automatically
                const arrayBuffer = await blob.arrayBuffer();
                const exportedFile = {
                    name: `${title}.epub`,
                    type: 'EPUB',
                    size: blob.size,
                    rawData: arrayBuffer,
                    content: null,
                    chapters: chapters,
                    metadata: {
                        title: title,
                        author: author,
                        language: language,
                        cover: file.metadata?.cover || null // Preserve original cover
                    }
                };

                // Parse the exported EPUB to get full content
                try {
                    const parsedEpub = await parseEpub(arrayBuffer);
                    exportedFile.content = parsedEpub.content;
                    exportedFile.chapters = parsedEpub.chapters;
                    // Keep the original cover if the new one wasn't found
                    if (!parsedEpub.metadata.cover && file.metadata?.cover) {
                        exportedFile.metadata.cover = file.metadata.cover;
                    } else if (parsedEpub.metadata.cover) {
                        exportedFile.metadata.cover = parsedEpub.metadata.cover;
                    }
                } catch (e) {
                    console.log('Could not parse exported EPUB, using original data');
                    exportedFile.content = file.content;
                }

                // Check if already in library (by name)
                const existingIndex = state.files.findIndex(f => f.name === exportedFile.name);
                if (existingIndex >= 0) {
                    state.files[existingIndex] = exportedFile;
                } else {
                    state.files.push(exportedFile);
                }

                if (!state.notes[exportedFile.name]) {
                    state.notes[exportedFile.name] = notes;
                }

                renderFileList();
                URL.revokeObjectURL(url);

                closeExportModal();
                showToast('EPUB exported and added to library!', 'success');

            } catch (err) {
                console.error('Export error:', err);
                showToast('Export failed: ' + err.message, 'error');
            }
        }

        // Utilities
        function escapeHtml(str) {
            if (!str) return '';
            return String(str).replace(/[&<>"']/g, c => ({
                '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'
            }[c]));
        }

        function escapeXml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        function deleteFile(index) {
            state.files.splice(index, 1);
            if (state.currentFileIndex === index) {
                state.currentFileIndex = -1;
                document.getElementById('readerHeader').style.display = 'none';
                document.getElementById('emptyState').style.display = 'flex';
                document.getElementById('pageView').style.display = 'none';
            } else if (state.currentFileIndex > index) {
                state.currentFileIndex--;
            }
            renderFileList();
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Initialize app
        init();
    </script>
</body>
</html>
